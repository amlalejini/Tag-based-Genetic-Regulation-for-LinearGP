[["index.html", "Analyses for Tag-based Genetic Regulation for Genetic Programming Chapter 1 Test", " Analyses for Tag-based Genetic Regulation for Genetic Programming Alexander Lalejini 2020-12-09 Chapter 1 Test "],["signalgp-digital-organisms.html", "Chapter 2 SignalGP Digital Organisms 2.1 Memory model 2.2 Mutation operators 2.3 Instruction Set 2.4 References", " Chapter 2 SignalGP Digital Organisms Here, we give more details on the setup of the SignalGP digital organisms used in the diagnostic experiments. For a broad overview of SignalGP, see (Lalejini and Ofria, 2018). For specific parameter choices, see experiment-specific configuration descriptions (TODO - link here). For DISHTINY SignalGP details, see DISHTINY docs. Navigation Memory model Mutation operators Instruction Set Default Instructions Global memory access instructions Regulation instructions Task-specific instructions References 2.1 Memory model SignalGP digital organisms have four types of memory buffers with which to carry out computations: Working (register) memory Call-local (* thread-local) memory. Memory used by the majority of computation instructions. Input memory Call-local (&amp; thread-local) memory. Read-only. This memory is used to specify function call arguments. When a function is called on a thread (i.e., a call instruction is executed), the caller’s working memory is copied into the input memory of the new call-state, which is created on top of the thread’s call stack. Programs must execute explicit instructions to read from the input memory buffer (into the working memory buffer). Output memory Call-local (&amp; thread-local) memory. Write-only. This memory is used to specify the return values of a function call. When a function returns to the previous call-state (i.e., the one just below it on the thread’s call stack), positions that were set in the output buffer are returned to the caller’s working memory buffer. Programs must execute explicit instructions to write to the output memory buffer (from the working memory buffer). Global memory This memory buffer is shared by all executing threads. Threads must use explicit instructions (GlobalToWorking or WorkingToGlobal) to access it. These are described in more detail in (Lalejini and Ofria, 2018). Memory buffers are implemented as integer =&gt; double maps. 2.2 Mutation operators Single-instruction insertions Applied per instruction Single-instruction deletions Applied per instruction Single-instruction substitutions Applied per instruction Single-argument substitutions Applied per argument Slip mutations (Lalejini et al., 2017) Applied at a per-function rate. Pick two random positions in function’s instructions sequence: A and B If A &lt; B: duplicate sequence from A to B If A &gt; B: delete sequence from A to B Single-function duplications Applied per-function Single-function deletions Applied per-function Tag bit flips Applied at a per-bit rate (applies to both instruction- and function-tags) 2.3 Instruction Set Abbreviations: EOP: End of program Reg: local register Reg[0] indicates the value at the register specified by an instruction’s first argument (either tag-based or numeric), Reg[1] indicates the value at the register specified by an instruction’s second argument, and Reg[2] indicates the value at the register specified by the instruction’s third argument. Reg[0], Reg[1], etc: Register 0, Register 1, etc. Input: input buffer Follows same scheme as Reg Output: output buffer Follows same scheme as Reg Arg: Instruction argument Arg[i] indicates the i’th instruction argument (an integer encoded in the genome) E.g., Arg[0] is an instruction’s first argument Instructions that would produce undefined behavior (e.g., division by zero) are treated as no operations. 2.3.1 Default Instructions I.e., instructions used across all diagnostic tasks. Instruction Arguments Used Description Nop 0 No operation Not 1 Reg[0] = !Reg[0] Inc 1 Reg[0] = Reg[0] + 1 Dec 1 Reg[0] = Reg[0] - 1 Add 3 Reg[2] = Reg[0] + Reg[1] Sub 3 Reg[2] = Reg[0] - Reg[1] Mult 3 Reg[2] = Reg[0] * Reg[1] Div 3 Reg[2] = Reg[0] / Reg[1] Mod 3 Reg[2] = Reg[0] % Reg[1] TestEqu 3 Reg[2] = Reg[0] == Reg[1] TestNEqu 3 Reg[2] = Reg[0] != Reg[1] TestLess 3 Reg[2] = Reg[0] &lt; Reg[1] TestLessEqu 3 Reg[2] = Reg[0] &lt;= Reg[1] TestGreater 3 Reg[2] = Reg[0] &gt; Reg[1] TestGreaterEqu 3 Reg[2] = Reg[0] &gt;= Reg[1] SetMem 2 Reg[0] = Arg[1] Terminal 1 Reg[0] = double value encoded by instruction tag CopyMem 2 Reg[0] = Reg[1] SwapMem 2 Swap(Reg[0], Reg[1]) InputToWorking 2 Reg[1] = Input[0] WorkingToOutput 2 Output[1] = Reg[0] If 1 If Reg[0] != 0, proceed. Otherwise skip to the next Close or EOP. While 1 While Reg[0] != 0, loop. Otherwise skip to next Close or EOP. Close 0 Indicate the end of a control block of code (e.g., loop, if). Break 0 Break out of current control flow (e.g., loop). Terminate 0 Kill thread that this instruction is executing on. Fork 0 Generate an internal signal (using this instruction’s tag) that can trigger a function to run in parallel. Call 0 Call a function, using this instruction’s tag to determine which function is called. Routine 0 Same as call, but local memory is shared. Sort of like a jump that will jump back when the routine ends. Return 0 Return from the current function call. 2.3.2 Global memory access instructions For experimental conditions without global memory access, these instructions are replaced with no-operation such that the instruction set remains a constant size regardless of experimental condition. Instruction Arguments Used Description WorkingToGlobal 2 Global[1] = Reg[0] GlobalToWorking 2 Reg[1] = Global[0] 2.3.3 Regulation instructions For experimental conditions without regulation, these instructions are replaced with no-operation such that the instruction set remains a constant size regardless of experimental condition. Note that several regulation instructions have a baseline and (-) version. The (-) versions are identical to the baseline version, except that they multiply the value they are regulating with by -1. This eliminates any bias toward either up-/down-regulation. Also note that the emp::MatchBin (in the Empirical library) data structure that manages function regulation is defined in terms of tag DISTANCE, not similarity. So, decreasing function regulation values decreases the distance between potential referring tags, and thus, unintuitively, up-regulates the function. All tag-based referencing used by regulation instructions use unregulated, raw match scores. Thus, programs can still up-regulate a function that was previously ‘turned off’ with down-regulation. Instruction Arguments Used Description SetRegulator 1 Set regulation value of function (targeted with instruction tag) to Reg[0]. SetRegulator- 1 Set regulation value of function (targeted with instruction tag) to -1 * Reg[0]. SetOwnRegulator 1 Set regulation value of function (currently executing) to Reg[0]. SetOwnRegulator- 1 Set regulation value of function (currently executing) to -1 * Reg[0]. AdjRegulator 1 Regulation value of function (targeted with instruction tag) += Reg[0] AdjRegulator- 1 Regulation value of function (targeted with instruction tag) -= Reg[0] AdjOwnRegulator 1 Regulation value of function (currently executing) += Reg[0] AdjOwnRegulator- 1 Regulation value of function (currently executing) -= Reg[0] ClearRegulator 0 Clear function regulation (reset to neutral) of function targeted by instruction’s tag. ClearOwnRegulator 0 Clear function regulation (reset to neutral) of currently executing function SenseRegulator 1 Reg[0] = regulator state of function targeted by instruction tag SenseOwnRegulator 1 Reg[0] = regulator state of current function IncRegulator 0 Increment regulator state of function targeted with this instruction’s tag IncOwnRegulator 0 Increment regulator state of currently executing function DecRegulator 0 Decrement regulator state of function targeted with this instruction’s tag DecOwnRegulator 0 Decrement regulator state of the currently executing function 2.3.4 Task-specific instructions Each task as a number of response instructions added to the instruction set equal to the possible set of responses that can be expressed by a digital organism. Each of these response instructions set a flag on the virtual hardware indicating which response the organism expressed and reset all executing threads such that only function regulation and global memory contents persist. 2.4 References Lalejini, A., &amp; Ofria, C. (2018). Evolving event-driven programs with SignalGP. Proceedings of the Genetic and Evolutionary Computation Conference on - GECCO ’18, 1135–1142. https://doi.org/10.1145/3205455.3205523 Lalejini, A., Wiser, M. J., &amp; Ofria, C. (2017). Gene duplications drive the evolution of complex traits and regulation. Proceedings of the 14th European Conference on Artificial Life ECAL 2017, 257–264. https://doi.org/10.7551/ecal_a_045 "],["changing-signal-problem-analysis.html", "Chapter 3 Changing-signal problem analysis 3.1 Overview 3.2 Analysis Dependencies 3.3 Setup 3.4 Does regulation hinder the evolution of successful genotypes?", " Chapter 3 Changing-signal problem analysis Here, we give an overview of the changing-signal diagnostic problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 3.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 env_complexities &lt;- c(16) # Settings for statistical analyses. alpha &lt;- 0.05 correction_method &lt;- &quot;bonferroni&quot; # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-11-chg-sig/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis The changing-signal task requires programs to express a unique response for each of \\(K\\) distinct environmental signals (i.e., each signal has a distinct tag); the figure below is given as an example. Because signals are distinct, programs do not need to alter their responses to particular signals over time. Instead, programs may ‘hardware’ each of the \\(K\\) possible responses to the appropriate environmental signal. However, environmental signals are presented in a random order; thus, the correct order of responses will vary and cannot be hardcoded. As in the repeated signal task, programs respond by executing one of \\(K\\) response instructions. Otherwise, evaluation (and fitness assignment) on the changing-signal task mirrors that of the repeated signal task. Requiring programs to express a distinct instruction in response to each environmental signal represents programs having to perform distinct behaviors. We afforded programs 128 time steps to express the appropriate response after receiving an environmental signal. Once the allotted time to respond expires or the program expresses any response, the program’s threads of execution are reset, resulting in a loss of all thread-local memory. Only the contents of a program’s global memory and each function’s regulatory state persist. The environment then produces the next signal (distinct from all previous signals) to which the program may respond. A program’s fitness is equal to the number of correct responses expressed during evaluation. We evolved populations of 1000 SignalGP programs to solve the changing-signal task at \\(K=16\\) (where \\(K\\) denotes the number of environmental signals). We evolved populations for 10^{4} generations or until an program capable of achieving a perfect score during task evaluation (i.e., able to express the appropriate response to each of the \\(K\\) signals) evolved. We ran 200 replicate populations (each with a distinct random number seed) of each of the following experimental conditions: a regulation-enabled treatment where programs have access to genetic regulation. a regulation-disabled treatment where programs do not have access to genetic regulation. Note this task does not require programs to shift their response to particular signals over time, and as such, genetic regulation is unnecessary. Further, because programs experience environmental inputs in a random order, erroneous genetic regulation can manifest as cryptic variation. For example, non-adaptive down-regulation of a particular response function may be neutral given one sequence of environmental signals, but may be deleterious in another. We expected regulation-enabled SignalGP to exhibit non-adaptive plasticity, potentially resulting in slower adaptation and non-general solutions. 3.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 3.3 Setup Load data, initial data cleanup, configure some global settings. # Load data file data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # For convenience, create a data set with only solutions # Filter data to include only replicates labeled as solutions sol_data &lt;- filter( data, solution==&quot;1&quot; ) # A lookup table for task complexities task_label_lu &lt;- c( &quot;2&quot; = &quot;2-signal task&quot;, &quot;4&quot; = &quot;4-signal task&quot;, &quot;8&quot; = &quot;8-signal task&quot;, &quot;16&quot; = &quot;16-signal task&quot;, &quot;32&quot; =&quot;32-signal task&quot; ) # Configure our default graphing theme theme_set(theme_cowplot()) 3.4 Does regulation hinder the evolution of successful genotypes? Here, we look at the number of solutions evolved under regulation-enabled and regulation-disabled conditions. A program is categorized as a ‘solution’ if it can correctly respond to each of the \\(K\\) environmental signals during evaluation. # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot( sol_data, aes(x=condition, fill=condition) ) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;,&quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates (/200)&quot;) + theme(legend.position = &quot;none&quot;) + ggtitle(&quot;Successful replicates&quot;) Programs capable of achieving a perfect score on the changing-signal task (for a given sequence of environment signals) evolve in all 200 replicates of each condition (i.e., with and without access to genetic regulation). These programs, however, do not necessarily generalize across all possible sequences of environmental signals. 3.4.1 Does access to regulation slow adaptation? I.e., did successful regulation-enabled programs take longer (more generations) to evolve than those evolved in the regulation-disabled treatment? ggplot( sol_data, aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( aes(y = update, color = condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;,&quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous( name=&quot;Generation first solution evolved \\n(log scale)&quot;, ) + guides(fill = FALSE) + guides(color = FALSE) print(wilcox.test(formula=update~condition, data=sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 22188, p-value = 0.05845 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -3.860236e-05 1.000000e+01 ## sample estimates: ## difference in location ## 5.000013 The difference in the number of generations before a solution arises is not significantly different. 3.4.2 Do they generalize? Note that solutions may or may not generalize beyond the sequence of environmental signals on which they achieved a perfect score (and were thus categorized as a ‘solution’). We re-evaluated each ‘solution’ on a random sample of 5000 sequences of environmental signals to test for generalization. We deem programs as having successfully generalized only if they responded correctly in all 5000 tests. To see if regulation is preventing some regulation-enabled solutions from generalizing, we test generalization for regulation-enabled solutions with their regulation faculties knocked out (i.e., regulation instructions replaced with no-operations). # Grab count data to make bar plot life easier num_solutions_reg &lt;- length(filter(data, condition==&quot;both&quot; &amp; solution==&quot;1&quot;)$SEED) num_generalize_reg &lt;- length(filter(data, condition==&quot;both&quot; &amp; all_solution==&quot;1&quot;)$SEED) num_generalize_ko_reg &lt;- length(filter(data, condition==&quot;both&quot; &amp; all_solution_ko_reg==&quot;1&quot;)$SEED) num_generalize_mem &lt;- length(filter(data, condition==&quot;memory&quot; &amp; all_solution==&quot;1&quot;)$SEED) sol_cnts &lt;- data.frame(x=1:3) sol_cnts$type &lt;- c(&quot;reg_generalize&quot;, &quot;reg_generalize_ko_reg&quot;, &quot;mem_generalize&quot;) sol_cnts$val &lt;- c(num_generalize_reg, num_generalize_ko_reg, num_generalize_mem) ggplot( sol_cnts, aes(x=type, y=val, fill=type) ) + geom_bar(stat=&quot;identity&quot;) + geom_text( aes(label=val), stat=&quot;identity&quot;, position=position_dodge(0.75), vjust=-0.01 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=c( &quot;mem_generalize&quot;, &quot;reg_generalize&quot;, &quot;reg_generalize_ko_reg&quot; ), labels=c( &quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;, &quot;Regulation-\\nenabled\\n(reg. KO)&quot; ) ) + scale_y_continuous( name=&quot;# of solutions that generalize&quot;, limits=c(0, 210), breaks=seq(0,200,50) ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size=10) ) + ggsave(paste0(working_directory, &quot;imgs/chg-env-16-generalization.png&quot;), width=4,height=4) All regulation-disabled programs successfully generalized. table &lt;- matrix(c(num_generalize_reg, num_generalize_mem, 200 - num_generalize_reg, 200 - num_generalize_mem), nrow=2) rownames(table) &lt;- c(&quot;reg-augmented&quot;, &quot;reg-disabled&quot;) colnames(table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(table) ## success fail ## reg-augmented 182 18 ## reg-disabled 200 0 fisher.test(table) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: table ## p-value = 5.113e-06 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.0000000 0.2115509 ## sample estimates: ## odds ratio ## 0 The difference in number of generalizing solutions between regulation-enabled and regulation-disabled conditions is statistically significant (Fisher’s exact test). Moreover, 5 of the 18 non-generalizing programs generalize when we knockout genetic regulation. Upon close inspection, the other 13 non-general programs relied on genetic regulation to achieve initial success but failed to generalize to arbitrary environment signal sequences. "],["repeated-signal-problem-analysis.html", "Chapter 4 Repeated-signal problem analysis 4.1 Overview 4.2 Analysis Dependencies 4.3 Setup 4.4 Problem-solving success 4.5 How many generations elapse before solutions evolve? 4.6 Teasing apart evolved strategies 4.7 Case study: visualizing regulation in an evolved program", " Chapter 4 Repeated-signal problem analysis Here, we give an overview of the repeated-signal diagnostic problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 4.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 env_complexities &lt;- c(2, 4, 8, 16) # Settings for statistical analyses. alpha &lt;- 0.05 correction_method &lt;- &quot;bonferroni&quot; # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-25-rep-sig/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis The repeated-signal problem requires programs to output the appropriate (distinct) response to a single environmental signal each of the \\(K\\) times the signal is repeated. Programs output responses by executing one of \\(K\\) response instructions. For example, if a program receives two signals from the environment during evaluation (i.e., \\(K=2\\)), the program should execute Response-1 after the first signal and Response-2 after the second signal. We afford programs 128 time steps to respond to each environmental signal. Once the allotted time expires or the program executes any response, the program’s threads of execution are reset, resulting in a loss of all thread-local memory; only the contents of the global memory buffer and each program module’s regulatory state persist. The environment then produces the next signal (identical to each previous environmental signal) to which the program may respond. A program must use the global memory buffer or genetic regulation to correctly shift its response to each subsequent environmental signal. Evaluation continues in this way until the program correctly responds to each of the \\(K\\) environmental signals or until the program executes an incorrect response. A program’s fitness equals the number of correct responses given during evaluation, and a program is considered a solution if it correctly responds to each of the \\(K\\) environmental signals. 4.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(reshape2) library(cowplot) library(viridis) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 4.3 Setup Load data, initial data cleanup, configure some global settings. max_fit_org_data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs_noprogram.csv&quot;) reg_network_data_loc &lt;- paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;) inst_exec_data_loc &lt;- paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;) ####### Load max fit program data ####### max_fit_org_data &lt;- read.csv(max_fit_org_data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). max_fit_org_data$matchbin_thresh &lt;- factor( max_fit_org_data$matchbin_thresh, levels=c(0, 25, 50, 75) ) max_fit_org_data$NUM_SIGNAL_RESPONSES &lt;- factor( max_fit_org_data$NUM_SIGNAL_RESPONSES, levels=c(2, 4, 8, 16, 32) ) max_fit_org_data$NUM_ENV_CYCLES &lt;- factor( max_fit_org_data$NUM_ENV_CYCLES, levels=c(2, 4, 8, 16, 32) ) max_fit_org_data$TAG_LEN &lt;- factor( max_fit_org_data$TAG_LEN, levels=c(32, 64, 128, 256) ) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. max_fit_org_data$condition &lt;- mapply( get_con, max_fit_org_data$USE_FUNC_REGULATION, max_fit_org_data$USE_GLOBAL_MEMORY ) max_fit_org_data$condition &lt;- factor( max_fit_org_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Does this program rely on a stochastic strategy? max_fit_org_data$stochastic &lt;- 1 - max_fit_org_data$consistent max_fit_org_data$stochastic &lt;- factor( max_fit_org_data$stochastic, levels=c(0, 1) ) # Filter data to include only runs from regulation-enabled (&#39;both&#39;) and regulation-disabled (&#39;memory&#39;) conditions max_fit_org_data &lt;- filter(max_fit_org_data, condition %in% c(&quot;both&quot;, &quot;memory&quot;)) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(max_fit_org_data, solution==&quot;1&quot;) # Label solution strategies get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). sol_data$strategy &lt;- mapply( get_strategy, sol_data$relies_on_regulation, sol_data$relies_on_global_memory ) sol_data$strategy &lt;- factor( sol_data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) ####### Load network data ####### reg_network_data &lt;- read.csv(reg_network_data_loc, na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% max_fit_org_data$SEED) # Make a lookup function to get each run&#39;s environment complexity level. get_num_sig_resps &lt;- function(seed) { return(filter(max_fit_org_data, SEED==seed)$NUM_SIGNAL_RESPONSES) } reg_network_data$NUM_SIGNAL_RESPONSES &lt;- mapply( get_num_sig_resps, reg_network_data$run_id ) reg_network_data$NUM_SIGNAL_RESPONSES &lt;- factor(reg_network_data$NUM_SIGNAL_RESPONSES) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(inst_exec_data_loc, na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$NUM_SIGNAL_RESPONSES &lt;- factor( inst_exec_data$NUM_SIGNAL_RESPONSES, levels=c(2, 4, 8, 16, 32) ) inst_exec_data$NUM_ENV_CYCLES &lt;- factor( inst_exec_data$NUM_ENV_CYCLES, levels=c(2, 4, 8, 16, 32) ) # Labels for each label_lu &lt;- c( &quot;2&quot; = &quot;2-signal task&quot;, &quot;4&quot; = &quot;4-signal task&quot;, &quot;8&quot; = &quot;8-signal task&quot;, &quot;16&quot; = &quot;16-signal task&quot;, &quot;32&quot; =&quot;32-signal task&quot; ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 4.4 Problem-solving success We expected populations with access to genetic regulation to be more successful on the repeated-signal task than those evolved without access to genetic regulation. Further, we expected the success differential to increase with problem difficulty. We can look at (1) the number of successful replicates (i.e., replicates in which a program capable of perfectly solving the repeated signal task evolved) per condition and (2) the scores of the highest-fitness program evolved in each replicate. 4.4.1 Number of successful replicates by condition Note that a program is categorized as a ‘solution’ only if it can correctly respond to each of repetition of the environment signal. # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot( sol_data, aes(x=condition, fill=condition) ) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_y_continuous( name=&quot;# evolved solutions&quot;, breaks=seq(0, replicates, 50), limits=c(0, replicates+2) ) + scale_fill_discrete( name=&quot;Condition:&quot;, limits=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( name=&quot;Condition&quot;, limits=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + ggtitle(&quot;Solution Counts&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-solultion-cnts.png&quot;), width=8, height=4 ) We confirmed that each difficulty level of the repeated-signal problem is solvable without regulation using hand-coded SignalGP programs. We use a Fisher’s exact test to determine if there are significant differences (p &lt; 0.05) between the numbers of regulation-enabled versus regulation-disabled solutions for each problem difficulty. # This code chunk is sort of a monster to have things print out all pretty-like in the knitted HTML document. # For each environment complexity level, do a fisher&#39;s exact test and print results. for (env in env_complexities) { env_data &lt;- filter(max_fit_org_data, NUM_SIGNAL_RESPONSES==env) cat(&quot;#### &quot;, paste0(env, &quot;-signal task&quot;), &quot; - statistical analysis of solution counts \\n&quot;) # Extract successes/fails for each condition. mem_success_cnt &lt;- nrow(filter(env_data, solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) mem_fail_cnt &lt;- nrow(filter(env_data, condition==&quot;memory&quot;)) - mem_success_cnt both_success_cnt &lt;- nrow(filter(env_data, solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) both_fail_cnt &lt;- nrow(filter(env_data, condition==&quot;both&quot;)) - both_success_cnt # Regulation-disabled vs regulation-enabled mem_sgp_table &lt;- matrix(c(both_success_cnt, mem_success_cnt, both_fail_cnt, mem_fail_cnt), nrow=2) rownames(mem_sgp_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(mem_sgp_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) mem_sgp_fishers &lt;- fisher.test(mem_sgp_table) cat(&quot;\\n&quot;) cat(&quot;Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): \\n&quot;) cat(&quot;```\\n&quot;) print(mem_sgp_table) print(mem_sgp_fishers) cat(&quot;```\\n&quot;) cat(&quot;\\n&quot;) } 4.4.1.1 2-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 200 0 reg-disabled 137 63 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 23.54182 Inf sample estimates: odds ratio Inf 4.4.1.2 4-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 200 0 reg-disabled 8 192 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 953.6049 Inf sample estimates: odds ratio Inf 4.4.1.3 8-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 198 2 reg-disabled 0 200 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 2409.412 Inf sample estimates: odds ratio Inf 4.4.1.4 16-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 74 126 reg-disabled 0 200 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 30.12902 Inf sample estimates: odds ratio Inf 4.4.2 Aggregate fitness scores by condition Here, we visualize the raw task scores for the highest-fitness program from each run across all environments/conditions. ggplot( max_fit_org_data, aes(x=condition, y=score, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + ylab(&quot;Score (# correct responses)&quot;) + scale_color_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, scales=&quot;free_y&quot;, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) + ggtitle(&quot;Task Scores&quot;) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-scores.png&quot;), width=16, height=8 ) 4.5 How many generations elapse before solutions evolve? Do some conditions lead to the evolution of solutions in fewer generations than other conditions? Here, we compare the generation at which solutions arise (only at difficulty levels where regulation-disabled solutions evovled). ggplot( data = filter(sol_data, NUM_SIGNAL_RESPONSES %in% c(2, 4)), aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-enabled&quot;) ) + scale_y_continuous( name=&quot;Generation first solution evolved \\n(log scale)&quot;, limits=c(0, generations), breaks=c(0, 10, 100, 1000, 10000), trans=&quot;pseudo_log&quot; ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;./imgs/repeated-signal-solve-time-cloud.png&quot;), width=5, height=4 ) ## Warning: Removed 94 rows containing missing values (geom_point). ## Warning: Removed 94 rows containing missing values (geom_point). 4.5.1 Two-signal task - statistical analysis We compare the time to solution using a Wilcoxon rank-sum test. env_2_sol_data &lt;- filter( sol_data, NUM_SIGNAL_RESPONSES==2 ) print(wilcox.test(formula=update~condition, data=env_2_sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 24940, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 6.000004 11.000006 ## sample estimates: ## difference in location ## 7.999963 4.5.2 Four-signal task - statistical analysis We compare the time to solution using a Wilcoxon rank-sum test. env_4_sol_data &lt;- filter( sol_data, NUM_SIGNAL_RESPONSES==4 ) print(wilcox.test(formula=update~condition, data=env_4_sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 1456, p-value = 8.603e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 173 738 ## sample estimates: ## difference in location ## 319.636 4.6 Teasing apart evolved strategies We analyzed: mechanisms underlying capacity to adjust responses to input signals (using knockout experiments) whether programs used stochasticity as part of their strategy instruction execution traces 4.6.1 Do solutions rely on genetic regulation or global memory access to dynamically adjust responses? Here, we take a closer at the strategies employed by solutions evolved across environment complexities. For each evolved solution, we independently knocked out (disabled) tag-based regulation and global memory access, and we measured the fitness effects knocking each out. If a knockout resulted in a decrease in fitness, we labeled that program as relying on that functionality (global memory or genetic regulation) for success. The graph(s) below gives the proportion of solutions that rely exclusively on regulation, exclusively on global memory, on both global memory and regulation, and on neither functionality. Proportions as stacked bar chart: ggplot( data=sol_data, mapping=aes(x=NUM_SIGNAL_RESPONSES, fill=strategy) ) + geom_bar( position=&quot;fill&quot; ) + ylab(&quot;# of Solutions&quot;) + xlab(&quot;Environment Complexity&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c(&quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot;), labels=c(&quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot;) ) + facet_wrap(~condition) As fun donuts(?!): # https://www.r-graph-gallery.com/128-ring-or-donut-plot.html donut_data &lt;- data.frame( env=character(), count=numeric(), category=character() ) for (env in env_complexities) { env_donut_data &lt;- data.frame( env=c(env, env, env, env), count=c( nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use neither&quot;)), nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use memory&quot;)), nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use regulation&quot;)), nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use both&quot;)) ), category=c(&quot;neither&quot;, &quot;memory&quot;, &quot;regulation&quot;, &quot;both&quot;) ) env_donut_data &lt;- filter(env_donut_data, count &gt; 0) env_donut_data$fraction &lt;- env_donut_data$count / sum(env_donut_data$count) env_donut_data$ymax &lt;- cumsum(env_donut_data$fraction) env_donut_data$ymin &lt;- c(0, head(env_donut_data$ymax, n=-1)) env_donut_data$labelPosition &lt;- (env_donut_data$ymax + env_donut_data$ymin) / 2 env_donut_data$label &lt;- paste0(env_donut_data$count) donut_data&lt;-rbind(donut_data, env_donut_data) } ggplot( donut_data, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=category) ) + geom_rect() + geom_label( x=4, aes(y=labelPosition, label=label), size=4, show.legend = FALSE) + coord_polar(theta=&quot;y&quot;) + xlim(c(-1, 4)) + scale_fill_discrete( name=&quot;Strategy:&quot;, limits=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use both&quot;)) + theme_void() + theme(legend.position = &quot;bottom&quot;) + facet_wrap( ~env, nrow=1, labeller=labeller(env=label_lu) ) We can see that in conditions where programs have access to regulation, evolved solutions generally rely on regulation to adjust their responses to input signals. In conditions where memory is the only mechanism for solving the repeated-signal task, we see that all evolved solutions rely exclusively on global memory access for adjusting responses to input signals. 4.6.2 What forms of genetic regulation do evolved programs rely on? We used two approaches to tease apart forms of genetic regulation that evolved SignalGP programs rely on: We traced program execution step-by-step (including each function’s regulatory state) during evaluation on the repeated signal task and extracted regulatory interactions between executing functions as a directed graph. We draw a directed edge from function A to function B if B’s regulatory state changes while A is executing. We label each edge as up- or down-regulation. The distribution of edge types in these graphs hints at what strategy the program is using. We independently knockout up-regulation and down-regulation and record the fitness of knockout-variants. If fitness decreases when a target functionality is knocked out, we categorize the program as relying on that functionality. Note that the knockout data more directly indicates which forms of regulation a program relies on, as the gene regulation networks may include neutral and non-adaptive regulatory interactions. 4.6.2.1 Gene regulatory network edges Let’s only look at programs that solved the repeated-signal task and rely on regulation. First, total edges as a function of problem difficulty. relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg ), aes(x=NUM_SIGNAL_RESPONSES, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Get seeds (run ids) of replicates that rely on regulation and are a solution. melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot( melted_network_data, aes(x=NUM_SIGNAL_RESPONSES, y=reg_edges_cnt, color=reg_edge_type) ) + geom_boxplot() + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_color_discrete( name=&quot;Edge type:&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-regulation-edge-types.png&quot;), width=4, height=3 ) for (env in env_complexities) { print(paste(&quot;Environment&quot;, env)) print(paste0(&quot; Median repressing edges: &quot;, median(filter(melted_network_data, NUM_SIGNAL_RESPONSES==env &amp; reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt))) print(paste0(&quot; Median promoting edges: &quot;, median(filter(melted_network_data, NUM_SIGNAL_RESPONSES==env &amp; reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt))) wt &lt;- wilcox.test( formula=reg_edges_cnt ~ reg_edge_type, data=filter(melted_network_data, NUM_SIGNAL_RESPONSES==env), exact=FALSE, conf.int=TRUE ) print(wt) } ## [1] &quot;Environment 2&quot; ## [1] &quot; Median repressing edges: 3&quot; ## [1] &quot; Median promoting edges: 2&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 21990, p-value = 8.308e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 6.294052e-06 1.000039e+00 ## sample estimates: ## difference in location ## 0.9999429 ## ## [1] &quot;Environment 4&quot; ## [1] &quot; Median repressing edges: 6&quot; ## [1] &quot; Median promoting edges: 3&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 30971, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 2.999916 3.999984 ## sample estimates: ## difference in location ## 3.000027 ## ## [1] &quot;Environment 8&quot; ## [1] &quot; Median repressing edges: 9&quot; ## [1] &quot; Median promoting edges: 3&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 34138, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 5.000045 6.000012 ## sample estimates: ## difference in location ## 5.999952 ## ## [1] &quot;Environment 16&quot; ## [1] &quot; Median repressing edges: 16&quot; ## [1] &quot; Median promoting edges: 4&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 4984, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 11.00002 13.00001 ## sample estimates: ## difference in location ## 12.00003 4.6.2.2 Knockout experiments Do successful programs rely on: neither up- nor down-regulation? either up- or down-regulation interchangeably? only on down-regulation? only on up-regulation? # Limit the genotypes we&#39;re looking at to just solutions from the &#39;both&#39; and &#39;regulation&#39; conditions. relies_on_reg_orgs &lt;- filter( max_fit_org_data, solution==&quot;1&quot; &amp; relies_on_regulation==&quot;1&quot; ) Note that there are 661 total programs represented in the graphs below. # Data processing/clean up get_reg_relies_on &lt;- function(uses_down, uses_up, uses_reg) { if (uses_down == &quot;0&quot; &amp;&amp; uses_up == &quot;0&quot; &amp;&amp; uses_reg == &quot;0&quot;) { return(&quot;neither&quot;) } else if (uses_down == &quot;0&quot; &amp;&amp; uses_up == &quot;0&quot; &amp;&amp; uses_reg == &quot;1&quot;) { return(&quot;either&quot;) } else if (uses_down == &quot;0&quot; &amp;&amp; uses_up == &quot;1&quot;) { return(&quot;up-regulation-only&quot;) } else if (uses_down == &quot;1&quot; &amp;&amp; uses_up == &quot;0&quot;) { return(&quot;down-regulation-only&quot;) } else if (uses_down == &quot;1&quot; &amp;&amp; uses_up == &quot;1&quot;) { return(&quot;up-and-down-regulation&quot;) } else { return(&quot;UNKNOWN&quot;) } } relies_on_reg_orgs$regulation_type_usage &lt;- mapply( get_reg_relies_on, relies_on_reg_orgs$relies_on_down_reg, relies_on_reg_orgs$relies_on_up_reg, relies_on_reg_orgs$relies_on_regulation ) relies_on_reg_orgs$regulation_type_usage &lt;- factor( relies_on_reg_orgs$regulation_type_usage, levels=c( &quot;neither&quot;, &quot;either&quot;, &quot;up-regulation-only&quot;, &quot;down-regulation-only&quot;, &quot;up-and-down-regulation&quot; ) ) 4.6.2.2.1 Regulation usage by environment ggplot(relies_on_reg_orgs, aes(x=regulation_type_usage, fill=regulation_type_usage)) + geom_bar() + geom_text( stat=&quot;count&quot;, aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Regulation Usage&quot;, limits=c( &quot;neither&quot;, &quot;either&quot;, &quot;up-regulation-only&quot;, &quot;down-regulation-only&quot;, &quot;up-and-down-regulation&quot; ), labels=c( &quot;None&quot;, &quot;Either&quot;, &quot;Up\\n(only)&quot;, &quot;Down\\n(only)&quot;, &quot;Both&quot; ) ) + facet_wrap(~NUM_SIGNAL_RESPONSES) + theme(legend.position=&quot;none&quot;) + ggtitle(&quot;Regulation usage by environment&quot;) + ggsave( paste0(working_directory, &quot;imgs/rst-reg-usage-by-env.png&quot;), width=8, height=6 ) 4.6.2.2.2 Regulation usage across all environments ggplot(relies_on_reg_orgs, aes(x=regulation_type_usage, fill=regulation_type_usage)) + geom_bar() + geom_text( stat=&quot;count&quot;, aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Regulation Usage&quot;, limits=c( &quot;neither&quot;, &quot;either&quot;, &quot;up-regulation-only&quot;, &quot;down-regulation-only&quot;, &quot;up-and-down-regulation&quot; ), labels=c( &quot;None&quot;, &quot;Either&quot;, &quot;Up\\n(only)&quot;, &quot;Down\\n(only)&quot;, &quot;Both&quot; ) ) + theme(legend.position=&quot;none&quot;) + ggtitle(&quot;Regulation usage across all environments&quot;) + ggsave( paste0(working_directory, &quot;imgs/rst-reg-usage-total.png&quot;), width=8, height=6 ) 4.6.3 Are evolved programs relying on stochastic strategies? To confirm that evolved programs are not relying on stochastic approaches to solve the repeated signal task, we tested the most fit individual from each replicate at the end of each run three times. If program’s behavior was not identical across each of the three trials, we labeled is as using a stochastic strategy. ggplot( max_fit_org_data, aes(x=condition, fill=stochastic)) + geom_bar() + ggtitle(&quot;Stochastic Strategies?&quot;) + ylab(&quot;# Replicates&quot;) + ylim(0, replicates) + scale_fill_discrete( name=&quot;Strategy&quot;, limits=c(0, 1), labels=c(&quot;Deterministic&quot;, &quot;Stochastic&quot;) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + facet_wrap( ~NUM_SIGNAL_RESPONSES, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? We see no evidence of evolved programs relying on stochastic strategies to solve the repeated signal task: all programs responded consistently across trials. Note, this is unsurprising, as we did not give programs access to instructions capable of generating random values and ensured that the version of SignalGP virtual hardware used in this work operated in a deterministic manner. 4.6.4 Program instruction execution traces 4.6.4.1 Execution time How many time steps do evolved programs use to solve the repeated-signal task? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_color_discrete( name=&quot;Condition: &quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Two-signal task: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==2), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 23102, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 38.00000 51.99997 ## sample estimates: ## difference in location ## 44.99995 Four-signal task: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==4), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 1494.5, p-value = 3.214e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 67.99998 112.00000 ## sample estimates: ## difference in location ## 89.00002 4.6.4.2 Distribution of executed instruction types Here, we look at the distribution of instruction types that programs execute during evaluation. For this work, we are primarily interested in the proportions of control flow instructions executed. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_color_discrete( name=&quot;Condition: &quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Two-signal task statistical comparison: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==2), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 19580, p-value = 2.118e-11 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.02022011 0.03692075 ## sample estimates: ## difference in location ## 0.02817524 Four-signal task statistical comparison: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==4), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 1292.5, p-value = 0.003185 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.01577416 0.06398521 ## sample estimates: ## difference in location ## 0.04051067 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition: &quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + facet_wrap( ~NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + coord_flip() + theme( legend.position=&quot;bottom&quot; ) 4.7 Case study: visualizing regulation in an evolved program Let’s take a closer look at the behavioral/regulatory profile of a representative program that solves the four-signal version of the repeated signal task. trace_id &lt;- 20203 Specifically, we’ll be looking at the solution evolved in run id 2.0203^{4}. 4.7.1 Data wrangling case_study_info &lt;- read.csv( paste0(working_directory, &quot;data/max_fit_orgs_noprogram.csv&quot;), na.strings=&quot;NONE&quot; ) case_study_info &lt;- filter( case_study_info, SEED==trace_id ) # Extract relevant information about solution of interest. num_envs &lt;- case_study_info$NUM_SIGNAL_RESPONSES score &lt;- case_study_info$score is_sol &lt;- case_study_info$solution num_modules &lt;- case_study_info$num_modules # Load trace file associated with this solution. trace_file &lt;- paste0(working_directory, &quot;data/reg-traces/trace-reg_update-10000_run-id-&quot;, trace_id, &quot;.csv&quot;) trace_data &lt;- read.csv(trace_file, na.strings=&quot;NONE&quot;) trace_data$similarity_score &lt;- 1 - trace_data$match_score # Data cleanup/summarizing trace_data$triggered &lt;- (trace_data$env_signal_closest_match == trace_data$module_id) &amp; (trace_data$cpu_step == &quot;0&quot;) trace_data$is_running &lt;- trace_data$is_running &gt; 0 | trace_data$triggered | trace_data$is_cur_responding_function == &quot;1&quot; # Extract which modules responded and when response_time_steps &lt;- levels(factor(filter(trace_data, is_cur_responding_function==&quot;1&quot;)$time_step)) responses_by_env_update &lt;- list() for (t in response_time_steps) { env_update &lt;- levels(factor(filter(trace_data, time_step==t)$env_cycle)) if (env_update %in% names(responses_by_env_update)) { if (as.integer(t) &gt; as.integer(responses_by_env_update[env_update])) { responses_by_env_update[env_update] = t } } else { responses_by_env_update[env_update] = t } } # Build a list of modules that were triggered &amp; those that responded to a signal triggered_ids &lt;- levels(factor(filter(trace_data, triggered==TRUE)$module_id)) response_ids &lt;- levels(factor(filter(trace_data, is_cur_responding_function==&quot;1&quot;)$module_id)) trace_data$is_ever_active &lt;- trace_data$is_ever_active==&quot;1&quot; | trace_data$is_running | trace_data$module_id %in% triggered_ids | trace_data$module_id %in% response_ids trace_data$is_cur_responding_function &lt;- trace_data$is_cur_responding_function==&quot;1&quot; &amp; trace_data$time_step %in% responses_by_env_update # function to categorize each regulatory state as promoted, neutral, or repressed # remember, the regulatory states in our data file operate with tag DISTANCE in mind # as opposed to tag similarity, so: promotion =&gt; reg &lt; 0, repression =&gt; reg &gt; 0 categorize_reg_state &lt;- function(reg_state) { if (reg_state == 0) { return(&quot;neutral&quot;) } else if (reg_state &lt; 0) { return(&quot;promoted&quot;) } else if (reg_state &gt; 0) { return(&quot;repressed&quot;) } else { return(&quot;unknown&quot;) } } trace_data$regulator_state_simplified &lt;- mapply( categorize_reg_state, trace_data$regulator_state ) # Omit all in-active rows # Extract only rows that correspond with modules that were active during evaluation. active_data &lt;- filter(trace_data, is_ever_active==TRUE) # Do some work to have module ids appear in a nice order along axis. active_module_ids &lt;- levels(factor(active_data$module_id)) active_module_ids &lt;- as.integer(active_module_ids) module_id_map &lt;- as.data.frame(active_module_ids) module_id_map$order &lt;- order(module_id_map$active_module_ids) - 1 get_module_x_pos &lt;- function(module_id) { return(filter(module_id_map, active_module_ids==module_id)$order) } active_data$mod_id_x_pos &lt;- mapply(get_module_x_pos, active_data$module_id) 4.7.2 Function regulation over time First, let’s omit all non-active funcitons. Vertical orientation: out_name &lt;- paste0( working_directory, &quot;imgs/case-study-trace-id-&quot;, trace_id, &quot;-regulator-state-vertical.pdf&quot; ) ggplot( active_data, aes(x=mod_id_x_pos, y=time_step, fill=regulator_state_simplified) ) + scale_fill_viridis( name=&quot;Regulation:&quot;, limits=c( &quot;promoted&quot;, &quot;neutral&quot;, &quot;repressed&quot; ), labels=c( &quot;+&quot;, &quot;\\u00F8&quot;, &quot;-&quot; ), discrete=TRUE, direction=-1 ) + scale_x_discrete( name=&quot;Function ID&quot;, limits=seq(0, length(active_module_ids)-1, 1), labels=active_module_ids ) + scale_y_discrete( name=&quot;Time Step&quot;, limits=seq(0, 30, 5) ) + # Background tile color geom_tile( color=&quot;white&quot;, size=0.2, width=1, height=1, alpha=0.75 ) + # Highlight actively running functions geom_tile( data=filter(active_data, is_running==TRUE | triggered==TRUE), color=&quot;black&quot;, size=0.8, width=1, height=1 ) + # Environment delimiters geom_hline( yintercept=filter(active_data, cpu_step==0)$time_step - 0.5, size=1.25, color=&quot;black&quot; ) + # Draw points on triggered modules geom_point( data=filter(active_data, triggered==TRUE), shape=8, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + geom_point( data=filter(active_data, is_cur_responding_function==TRUE), shape=21, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + theme( legend.position = &quot;top&quot;, legend.text = element_text(size=9), legend.title=element_text(size=8), axis.text.y = element_text(size=8), axis.title.y = element_text(size=8), axis.text.x = element_text(size=8), axis.title.x = element_text(size=8), plot.title = element_text(hjust = 0.5) ) + ggsave( out_name, height=3.5, width=2.25 ) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? Horizontal orientation: out_name &lt;- paste0(working_directory, &quot;imgs/case-study-trace-id-&quot;,trace_id,&quot;-regulator-state-horizontal.pdf&quot;) ggplot(active_data, aes(x=mod_id_x_pos, y=time_step, fill=regulator_state_simplified)) + scale_fill_viridis( name=&quot;Regulation:&quot;, limits=c( &quot;promoted&quot;, &quot;neutral&quot;, &quot;repressed&quot; ), labels=c( &quot;+&quot;, &quot;\\u00F8&quot;, &quot;-&quot; ), discrete=TRUE, direction=-1 ) + scale_x_discrete( name=&quot;Function ID&quot;, limits=seq(0, length(active_module_ids)-1, 1), labels=active_module_ids ) + scale_y_discrete( name=&quot;Time Step&quot;, limits=seq(0, 30, 5) ) + # Background tile color geom_tile( color=&quot;white&quot;, size=0.2, width=1, height=1, alpha=0.75 ) + # Highlight actively running functions geom_tile( data=filter(active_data, is_running==TRUE | triggered==TRUE), color=&quot;black&quot;, size=0.8, width=1, height=1 ) + # Environment delimiters geom_hline( yintercept=filter(active_data, cpu_step==0)$time_step - 0.5, size=1.25, color=&quot;black&quot; ) + # Draw points on triggered modules geom_point( data=filter(active_data, triggered==TRUE), shape=8, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + geom_point( data=filter(active_data, is_cur_responding_function==TRUE), shape=21, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + theme( legend.position = &quot;top&quot;, legend.text = element_text(size=9), legend.title=element_text(size=8), axis.text.y = element_text(size=8), axis.title.y = element_text(size=8), axis.text.x = element_text(size=8), axis.title.x = element_text(size=8), plot.title = element_text(hjust = 0.5) ) + coord_flip() + ggsave(out_name, height=2.25, width=4) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? 4.7.3 Environmental signal tag-match score over time Again, we’ll omit unexecuted functions. out_name &lt;- paste0(working_directory, &quot;imgs/case-study-trace-id-&quot;, trace_id, &quot;-similarity-score.pdf&quot;, sep=&quot;&quot;) ggplot(active_data, aes(x=mod_id_x_pos, y=time_step, fill=similarity_score)) + scale_fill_viridis( option=&quot;plasma&quot;, name=&quot;Score: &quot; ) + scale_x_discrete( name=&quot;Function ID&quot;, limits=seq(0, length(active_module_ids)-1, 1), labels=active_module_ids ) + scale_y_discrete( name=&quot;Time Step&quot;, limits=seq(0, 30, 10) ) + # Background geom_tile( color=&quot;white&quot;, size=0.2, width=1, height=1 ) + # Module is-running highlights geom_tile( data=filter(active_data, is_running==TRUE | triggered==TRUE), color=&quot;black&quot;, width=1, height=1, size=0.8 ) + # Environment delimiters geom_hline( yintercept=filter(active_data, cpu_step==0)$time_step-0.5, size=1 ) + # Draw points on triggered modules geom_point( data=filter(active_data, triggered==TRUE), shape=8, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + geom_point( data=filter(active_data, is_cur_responding_function==TRUE), shape=21, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + theme( legend.position = &quot;top&quot;, legend.text = element_text(size=8), axis.text.y = element_text(size=8), axis.text.x = element_text(size=8) ) + guides(fill = guide_colourbar(barwidth = 10, barheight = 0.5)) + ggtitle(&quot;Function Match Scores&quot;) + ggsave(out_name, height=3, width=4) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? 4.7.4 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) ## Warning in read.table(file = file, header = header, sep = sep, quote = quote, : ## incomplete final line found by readTableHeader on &#39;experiments/2020-11-25-rep- ## sig/analysis/data/igraphs/reg_graph_id-20203_nodes.csv&#39; graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=40, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["contextual-signal-problem-analysis.html", "Chapter 5 Contextual-signal problem analysis 5.1 Overview 5.2 Analysis Dependencies 5.3 Setup 5.4 Problem-solving success 5.5 How many generations elapse before solutions evolve? 5.6 Evolved strategies 5.7 Visualizing an evolved gene regulatory network", " Chapter 5 Contextual-signal problem analysis Here, we give an overview of the contextual-signal diagnostic problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 5.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 # Settings for statistical analyses. alpha &lt;- 0.05 # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-27-context-sig/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis In the contextual-signal problem, programs must respond appropriately to a sequence of two input signals where the first, ‘’contextual’‘, signal dictates how a program should respond to each possible second,’‘response’’, signal. In this work, there are a total of four possible input signals and four possible output responses. Programs output these responses by executing one of four response instructions. The dataframe below gives the correct output for each combination of input signals. testcases &lt;- read.csv(paste0(working_directory, &quot;../hpcc/examples_S4.csv&quot;)) print(testcases) ## input output type ## 1 OP:S0;OP:S0 0 S0;S0 ## 2 OP:S0;OP:S1 1 S0;S1 ## 3 OP:S0;OP:S2 2 S0;S2 ## 4 OP:S0;OP:S3 3 S0;S3 ## 5 OP:S1;OP:S0 1 S1;S0 ## 6 OP:S1;OP:S1 2 S1;S1 ## 7 OP:S1;OP:S2 3 S1;S2 ## 8 OP:S1;OP:S3 0 S1;S3 ## 9 OP:S2;OP:S0 2 S2;S0 ## 10 OP:S2;OP:S1 3 S2;S1 ## 11 OP:S2;OP:S2 0 S2;S2 ## 12 OP:S2;OP:S3 1 S2;S3 ## 13 OP:S3;OP:S0 3 S3;S0 ## 14 OP:S3;OP:S1 0 S3;S1 ## 15 OP:S3;OP:S2 1 S3;S2 ## 16 OP:S3;OP:S3 2 S3;S3 5.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) library(reshape2) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 5.3 Setup Load data, initial data cleanup, configure some global settings. ####### Load max fit program data ####### data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). data$matchbin_thresh &lt;- factor( data$matchbin_thresh, levels=c(0, 25, 50, 75) ) data$TAG_LEN &lt;- factor( data$TAG_LEN, levels=c(32, 64, 128, 256) ) data$task &lt;- factor( data$task, levels=c(&quot;S2&quot;, &quot;S3&quot;, &quot;S4&quot;) ) # Filter down to only data we use in paper. data &lt;- filter(data, task==&quot;S4&quot;) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Given knockout info, what strategy does a program use? get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). data$strategy &lt;- mapply( get_strategy, data$relies_on_regulation, data$relies_on_global_memory ) data$strategy &lt;- factor( data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(data, solution==&quot;1&quot;) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;), na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$task &lt;- factor( inst_exec_data$task, levels=c(&quot;S2&quot;, &quot;S3&quot;, &quot;S4&quot;) ) ####### Load network data ####### reg_network_data &lt;- read.csv(paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;), na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% data$SEED) get_task &lt;- function(seed) { return(filter(data, SEED==seed)$task) } reg_network_data$task &lt;- mapply( get_task, reg_network_data$run_id ) reg_network_data$task &lt;- factor(reg_network_data$task) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 5.4 Problem-solving success The number of successful replicates by condition: # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot(filter(sol_data, task==&quot;S4&quot;), aes(x=condition, fill=condition)) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates&quot;) + theme(legend.position = &quot;none&quot;) + ggsave( paste0(working_directory, &quot;imgs/context-signal-solution-counts.pdf&quot;), width=4, height=4 ) Test for significance using Fisher’s exact test. # Extract successes/fails for each condition. reg_disabled_success_cnt &lt;- nrow(filter(sol_data, task==&quot;S4&quot; &amp; solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) reg_disabled_fail_cnt &lt;- replicates - reg_disabled_success_cnt reg_enabled_success_cnt &lt;- nrow(filter(sol_data, task==&quot;S4&quot; &amp; solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) reg_enabled_fail_cnt &lt;- replicates - reg_enabled_success_cnt # Regulation-disabled vs regulation-enabled perf_table &lt;- matrix( c( reg_enabled_success_cnt, reg_disabled_success_cnt, reg_enabled_fail_cnt, reg_disabled_fail_cnt ), nrow=2 ) rownames(perf_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(perf_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(perf_table) ## success fail ## reg-enabled 200 0 ## reg-disabled 173 27 print(fisher.test(perf_table)) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: perf_table ## p-value = 5.818e-09 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 7.714282 Inf ## sample estimates: ## odds ratio ## Inf 5.5 How many generations elapse before solutions evolve? ggplot( data = filter(sol_data, task==&quot;S4&quot;), aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position=position_nudge(x = .2, y = 0), alpha=.8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous(name=&quot;Generation first solution evolved&quot;) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;imgs/context-signal-solve-time-cloud.png&quot;), width=4, height=4 ) Test for statistical difference between conditions using a Wilcoxon rank sum test. print(wilcox.test(formula=update~condition, data=filter(sol_data, task==&quot;S4&quot;), exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 28950, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 557.9999 764.0000 ## sample estimates: ## difference in location ## 657 5.6 Evolved strategies 5.6.1 What mechanisms do programs rely on to adjust responses to signals over time? We used indpendent knockouts of tag-based genetic regulation and global memory buffer access to investigate the mechanisms underpinning successful programs. ggplot( filter(sol_data, task==&quot;S4&quot;), mapping=aes(x=condition, fill=strategy) ) + geom_bar( position=&quot;fill&quot;, stat=&quot;count&quot; ) + geom_text( stat=&#39;count&#39;, mapping=aes(label=..count..), position=position_fill(vjust=0.05) ) + ylab(&quot;% of Solutions&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ), labels=c( &quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot; ) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme(legend.position = &quot;bottom&quot;) 5.6.2 Gene regulatory networks Looking only at successful programs that rely on regulation. At a glance, what do gene regulatory networks look like? First, the total edges found in networks: relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg &amp; task==&quot;S4&quot;), aes(x=task, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Task&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/contextual-signal-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Process/cleanup the network data melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg ), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot(filter(melted_network_data, task==&quot;S4&quot;), aes(x=reg_edge_type, y=reg_edges_cnt, color=reg_edge_type)) + geom_boxplot() + geom_jitter(alpha=0.2) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_x_discrete( name=&quot;Edge type&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;none&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/context-signal-regulation-edge-types.png&quot;), width=4, height=3 ) Test for a statistical difference between edge types using a wilcoxon rank sum test: print( paste0( &quot;Median # repressed edges: &quot;, median(filter(melted_network_data, task==&quot;S4&quot; &amp; reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # repressed edges: 62&quot; print( paste0( &quot;Median # promoting edges: &quot;, median(filter(melted_network_data, task==&quot;S4&quot; &amp; reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # promoting edges: 73&quot; print(wilcox.test(formula=reg_edges_cnt ~ reg_edge_type, data=filter(melted_network_data, task==&quot;S4&quot;), exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 15690, p-value = 0.0001927 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -13.000026 -4.000018 ## sample estimates: ## difference in location ## -8.000026 5.6.3 Program instruction execution traces 5.6.3.1 Execution time How many time steps do evolved programs use to solve the contextual-signal task? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED &amp; task==&quot;S4&quot;) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme( legend.position=&quot;none&quot; ) Test for significant difference between conditions using Wilcoxon rank sum test: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 30794, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 634.0001 810.0000 ## sample estimates: ## difference in location ## 722.8488 5.6.3.2 What types of instructions to successful programs execute? Here, we look at the distribution of instruction types executed by successful programs. We’re primarily interested in the proportion of control flow instructions, so let’s look at that first. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Test for significant difference between conditions using a Wilcoxon rank sum test: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 30479, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.04280319 0.05431491 ## sample estimates: ## difference in location ## 0.04838185 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition:&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled&quot;, &quot;Regulation-enabled&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + coord_flip() + theme(legend.position=&quot;bottom&quot;) 5.7 Visualizing an evolved gene regulatory network Let’s take a closer look at a successful gene regulatory network. trace_id &lt;- 23997 Specifically, we’ll be looking at the solution evolved in run id 2.3997^{4} (arbitrarily selected). 5.7.1 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=10, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["boolean-calculator-problem-prefix-notation.html", "Chapter 6 Boolean calculator problem (prefix notation) 6.1 Overview 6.2 Analysis Dependencies 6.3 Setup 6.4 Problem-solving success 6.5 How many generations elapse before solutions evolve? 6.6 Evolved strategies 6.7 Visualizaing an evolved regulatory network", " Chapter 6 Boolean calculator problem (prefix notation) Here, we give an overview of the boolean logic calculator problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 6.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 # Settings for statistical analyses. alpha &lt;- 0.05 # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-28-bool-calc-prefix/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis The Boolean logic calculator problem requires programs to implement a calculator capable of performing each of the following 10 bitwise logic operations: ECHO, NOT, NAND, AND, OR-NOT, OR, AND-NOT, NOR, XOR, and EQUALS. In this problem, there are 11 distinct types of input signals: one for each of the 10 possible operators and one for numeric inputs. Each distinct signal type is associated with a unique tag and is meant to represent different types of buttons that could be pressed on a physical calculator. Programs receive a sequence of input signals in prefix notation, receiving an operator signal followed by the appropriate number of numeric input signals (that each contain an operand to use in the computation). After receiving the requisite input signals, programs must output the correct result of the requested computation. 6.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) library(reshape2) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 6.3 Setup Load data, initial data cleanup, configure some global settings. data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). data$matchbin_thresh &lt;- factor( data$matchbin_thresh, levels=c(0, 25, 50, 75) ) data$TAG_LEN &lt;- factor( data$TAG_LEN, levels=c(32, 64, 128, 256) ) data$notation &lt;- factor( data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Given knockout info, what strategy does a program use? get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). data$strategy &lt;- mapply( get_strategy, data$relies_on_regulation, data$relies_on_global_memory ) data$strategy &lt;- factor( data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(data, solution==&quot;1&quot;) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;), na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$notation &lt;- factor( inst_exec_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### Load network data ####### reg_network_data &lt;- read.csv(paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;), na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% data$SEED) get_notation &lt;- function(seed) { return(filter(data, SEED==seed)$notation) } reg_network_data$notation &lt;- mapply( get_notation, reg_network_data$run_id ) reg_network_data$notation &lt;- factor( reg_network_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 6.4 Problem-solving success The number of successful replicates by condition: # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot(sol_data, aes(x=condition, fill=condition)) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates&quot;) + ylim(0, 200) + theme(legend.position = &quot;none&quot;) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-solution-counts.pdf&quot;), width=4, height=4 ) Test for significance using Fisher’s exact test. # Extract successes/fails for each condition. reg_disabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) reg_disabled_fail_cnt &lt;- replicates - reg_disabled_success_cnt reg_enabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) reg_enabled_fail_cnt &lt;- replicates - reg_enabled_success_cnt # Regulation-disabled vs regulation-enabled perf_table &lt;- matrix( c( reg_enabled_success_cnt, reg_disabled_success_cnt, reg_enabled_fail_cnt, reg_disabled_fail_cnt ), nrow=2 ) rownames(perf_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(perf_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(perf_table) ## success fail ## reg-enabled 66 134 ## reg-disabled 30 170 print(fisher.test(perf_table)) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: perf_table ## p-value = 3.585e-05 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 1.673731 4.711896 ## sample estimates: ## odds ratio ## 2.783852 6.5 How many generations elapse before solutions evolve? ggplot( data = sol_data, aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position=position_nudge(x = .2, y = 0), alpha=.8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous(name=&quot;Generation first solution evolved&quot;) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-solve-time-cloud.png&quot;), width=4, height=4 ) Test for statistical difference between conditions using a Wilcoxon rank sum test. print(wilcox.test(formula=update~condition, data=sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 1249, p-value = 0.04102 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 45.00003 2448.99997 ## sample estimates: ## difference in location ## 1291.265 6.6 Evolved strategies 6.6.1 What mechanisms do programs rely on to adjust responses to signals over time? We used indpendent knockouts of tag-based genetic regulation and global memory buffer access to investigate the mechanisms underpinning successful programs. ggplot( sol_data, mapping=aes(x=condition, fill=strategy) ) + geom_bar( position=&quot;fill&quot;, stat=&quot;count&quot; ) + geom_text( stat=&#39;count&#39;, mapping=aes(label=..count..), position=position_fill(vjust=0.05) ) + ylab(&quot;% of Solutions&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ), labels=c( &quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot; ) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme(legend.position = &quot;bottom&quot;) 6.6.2 Gene regulatory networks Looking only at successful programs that rely on regulation. At a glance, what do gene regulatory networks look like? First, the total edges found in networks: relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg), aes(x=notation, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Notation&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Process/cleanup the network data melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg ), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot( melted_network_data, aes(x=reg_edge_type, y=reg_edges_cnt, color=reg_edge_type) ) + geom_boxplot() + geom_jitter(alpha=0.2) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_x_discrete( name=&quot;Edge type&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;none&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-regulation-edge-types.png&quot;), width=4, height=3 ) Test for a statistical difference between edge types using a wilcoxon rank sum test: print( paste0( &quot;Median # repressed edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # repressed edges: 34&quot; print( paste0( &quot;Median # promoting edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # promoting edges: 36&quot; print(wilcox.test(formula=reg_edges_cnt ~ reg_edge_type, data=melted_network_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 1961.5, p-value = 0.3254 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -8.999963 2.999998 ## sample estimates: ## difference in location ## -2.999964 6.6.3 Program instruction execution traces 6.6.3.1 Execution time How many time steps do successful programs take to solve the boolean calculator problem? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme( legend.position=&quot;none&quot; ) Test for significant difference between conditions using Wilcoxon rank sum test: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 1374, p-value = 0.002434 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 240 986 ## sample estimates: ## difference in location ## 587.0774 6.6.3.2 What types of instructions to successful programs execute? Here, we look at the distribution of instruction types executed by successful programs. We’re primarily interested in the proportion of control flow instructions, so let’s look at that first. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Test for significant difference between conditions using a Wilcoxon rank sum test: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 1541.5, p-value = 1.328e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.01486019 0.03910795 ## sample estimates: ## difference in location ## 0.02639857 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition:&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled&quot;, &quot;Regulation-enabled&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + coord_flip() + theme(legend.position=&quot;bottom&quot;) 6.7 Visualizaing an evolved regulatory network Let’s take a closer look at a successful gene regulatory network. trace_id &lt;- 24386 Specifically, we’ll be looking at the solution evolved in run id 2.4386^{4} (arbitrarily selected). 6.7.1 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=10, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["boolean-calculator-problem-postfix-notation.html", "Chapter 7 Boolean calculator problem (postfix notation) 7.1 Overview 7.2 Analysis Dependencies 7.3 Setup 7.4 Problem-solving success 7.5 How many generations elapse before solutions evolve? 7.6 Evolved strategies 7.7 Visualizaing an evolved regulatory network", " Chapter 7 Boolean calculator problem (postfix notation) Here, we give an overview of the boolean logic calculator problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 7.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 # Settings for statistical analyses. alpha &lt;- 0.05 # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-28-bool-calc-postfix/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis We use a modified version of the Boolean logic calculator problem to further investigate the potential for our implementation of tag-based regulation to impede adaptive evolution. Our previous experiments with the Boolean logic calculator problem provided inputs in prefix notation: the operator (e.g., AND, OR, XOR, etc.) is specified first, followed by the requisite number of numeric operands. As such, the final input signal does not differentiate which type of computation a program is expected to perform (e.g., AND, OR, XOR, etc.). This requires programs to adjust their response to the final input signal based on the context provided by the previous two signals, thereby increasing the value of regulation. We explore whether the calculator problem’s context-dependence is driving the benefit of tag-based regulation that we identified in previous experiments. We can reduce context-dependence of the calculator problem by presenting input sequences in postfix notation. In postfix notation, programs receive the requisite numeric operand inputs first and the operator input last. As such, the final signal in an input sequence will always differentiate which bitwise operation should be performed. Successful programs must store the numeric inputs embedded in operand signals, and then, as in the changing-signal problem, a distinct signal will differentiate which of the response types a program should execute. 7.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) library(reshape2) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 7.3 Setup Load data, initial data cleanup, configure some global settings. data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). data$matchbin_thresh &lt;- factor( data$matchbin_thresh, levels=c(0, 25, 50, 75) ) data$TAG_LEN &lt;- factor( data$TAG_LEN, levels=c(32, 64, 128, 256) ) data$notation &lt;- factor( data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Given knockout info, what strategy does a program use? get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). data$strategy &lt;- mapply( get_strategy, data$relies_on_regulation, data$relies_on_global_memory ) data$strategy &lt;- factor( data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(data, solution==&quot;1&quot;) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;), na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$notation &lt;- factor( inst_exec_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### Load network data ####### reg_network_data &lt;- read.csv(paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;), na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% data$SEED) get_notation &lt;- function(seed) { return(filter(data, SEED==seed)$notation) } reg_network_data$notation &lt;- mapply( get_notation, reg_network_data$run_id ) reg_network_data$notation &lt;- factor( reg_network_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 7.4 Problem-solving success The number of successful replicates by condition: # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot(sol_data, aes(x=condition, fill=condition)) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates&quot;) + ylim(0, 200) + theme(legend.position = &quot;none&quot;) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-solution-counts.pdf&quot;), width=4, height=4 ) Test for significance using Fisher’s exact test. # Extract successes/fails for each condition. reg_disabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) reg_disabled_fail_cnt &lt;- replicates - reg_disabled_success_cnt reg_enabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) reg_enabled_fail_cnt &lt;- replicates - reg_enabled_success_cnt # Regulation-disabled vs regulation-enabled perf_table &lt;- matrix( c( reg_enabled_success_cnt, reg_disabled_success_cnt, reg_enabled_fail_cnt, reg_disabled_fail_cnt ), nrow=2 ) rownames(perf_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(perf_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(perf_table) ## success fail ## reg-enabled 120 80 ## reg-disabled 151 49 print(fisher.test(perf_table)) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: perf_table ## p-value = 0.001286 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.3093253 0.7635173 ## sample estimates: ## odds ratio ## 0.4876392 7.5 How many generations elapse before solutions evolve? ggplot( data = sol_data, aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position=position_nudge(x = .2, y = 0), alpha=.8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous(name=&quot;Generation first solution evolved&quot;) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-solve-time-cloud.png&quot;), width=4, height=4 ) Test for statistical difference between conditions using a Wilcoxon rank sum test. print(wilcox.test(formula=update~condition, data=sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 7175.5, p-value = 0.003285 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -1422 -310 ## sample estimates: ## difference in location ## -872 7.6 Evolved strategies 7.6.1 What mechanisms do programs rely on to adjust responses to signals over time? We used indpendent knockouts of tag-based genetic regulation and global memory buffer access to investigate the mechanisms underpinning successful programs. ggplot( sol_data, mapping=aes(x=condition, fill=strategy) ) + geom_bar( position=&quot;fill&quot;, stat=&quot;count&quot; ) + geom_text( stat=&#39;count&#39;, mapping=aes(label=..count..), position=position_fill(vjust=0.05) ) + ylab(&quot;% of Solutions&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ), labels=c( &quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot; ) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme(legend.position = &quot;bottom&quot;) 7.6.2 Gene regulatory networks Looking only at successful programs that rely on regulation. At a glance, what do gene regulatory networks look like? First, the total edges found in networks: relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg), aes(x=notation, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Notation&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Process/cleanup the network data melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg ), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot( melted_network_data, aes(x=reg_edge_type, y=reg_edges_cnt, color=reg_edge_type) ) + geom_boxplot() + geom_jitter(alpha=0.2) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_x_discrete( name=&quot;Edge type&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;none&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-regulation-edge-types.png&quot;), width=4, height=3 ) Test for a statistical difference between edge types using a wilcoxon rank sum test: print( paste0( &quot;Median # repressed edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # repressed edges: 41&quot; print( paste0( &quot;Median # promoting edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # promoting edges: 43&quot; print(wilcox.test(formula=reg_edges_cnt ~ reg_edge_type, data=melted_network_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 4411, p-value = 0.4535 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -7.999975 3.000061 ## sample estimates: ## difference in location ## -1.999985 7.6.3 Program instruction execution traces 7.6.3.1 Execution time How many time steps do successful programs take to solve the boolean calculator problem? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme( legend.position=&quot;none&quot; ) Test for significant difference between conditions using Wilcoxon rank sum test: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 9737, p-value = 0.2912 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -78.00002 274.00000 ## sample estimates: ## difference in location ## 96.00004 7.6.3.2 What types of instructions to successful programs execute? Here, we look at the distribution of instruction types executed by successful programs. We’re primarily interested in the proportion of control flow instructions, so let’s look at that first. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Test for significant difference between conditions using a Wilcoxon rank sum test: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 8043, p-value = 0.1127 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -0.011679066 0.001195076 ## sample estimates: ## difference in location ## -0.00543344 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition:&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled&quot;, &quot;Regulation-enabled&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + coord_flip() + theme(legend.position=&quot;bottom&quot;) 7.7 Visualizaing an evolved regulatory network Let’s take a closer look at a successful gene regulatory network. trace_id &lt;- 25392 Specifically, we’ll be looking at the solution evolved in run id 2.5392^{4} (arbitrarily selected). 7.7.1 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=10, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["references-1.html", "References", " References Csardi, Gabor, and Tamas Nepusz. 2006. “The Igraph Software Package for Complex Network Research.” InterJournal Complex Systems: 1695. https://igraph.org. file., See AUTHORS. 2020. Igraph: Network Analysis and Visualization. https://igraph.org. Garnier, Simon. 2018a. Viridis: Default Color Maps from Matplotlib. https://github.com/sjmgarnier/viridis. ———. 2018b. ViridisLite: Default Color Maps from Matplotlib (Lite Version). https://github.com/sjmgarnier/viridisLite. Henry, Lionel, and Hadley Wickham. 2020. Purrr: Functional Programming Tools. https://CRAN.R-project.org/package=purrr. Müller, Kirill, and Hadley Wickham. 2020. Tibble: Simple Data Frames. https://CRAN.R-project.org/package=tibble. R Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Wickham, Hadley. 2007. “Reshaping Data with the reshape Package.” Journal of Statistical Software 21 (12): 1–20. http://www.jstatsoft.org/v21/i12/. ———. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org. ———. 2019a. Stringr: Simple, Consistent Wrappers for Common String Operations. https://CRAN.R-project.org/package=stringr. ———. 2019b. Tidyverse: Easily Install and Load the Tidyverse. https://CRAN.R-project.org/package=tidyverse. ———. 2020a. Forcats: Tools for Working with Categorical Variables (Factors). https://CRAN.R-project.org/package=forcats. ———. 2020b. Reshape2: Flexibly Reshape Data: A Reboot of the Reshape Package. https://github.com/hadley/reshape. ———. 2020c. Tidyr: Tidy Messy Data. https://CRAN.R-project.org/package=tidyr. Wickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. “Welcome to the tidyverse.” Journal of Open Source Software 4 (43): 1686. https://doi.org/10.21105/joss.01686. Wickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey Dunnington. 2020. Ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics. https://CRAN.R-project.org/package=ggplot2. Wickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2020. Dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr. Wickham, Hadley, and Jim Hester. 2020. Readr: Read Rectangular Text Data. https://CRAN.R-project.org/package=readr. Wilke, Claus O. 2020. Cowplot: Streamlined Plot Theme and Plot Annotations for Ggplot2. https://wilkelab.org/cowplot/. Xie, Yihui. 2016. Bookdown: Authoring Books and Technical Documents with R Markdown. Boca Raton, Florida: Chapman; Hall/CRC. https://github.com/rstudio/bookdown. ———. 2020. Bookdown: Authoring Books and Technical Documents with R Markdown. https://github.com/rstudio/bookdown. "]]
