[["index.html", "Supplemental Material for Tag-based Genetic Regulation for Genetic Programming Chapter 1 Introduction 1.1 About our supplemental material 1.2 Contributing authors 1.3 Research overview", " Supplemental Material for Tag-based Genetic Regulation for Genetic Programming Alexander Lalejini, Matthew Andres Moreno, and Charles Ofria 2020-12-09 Chapter 1 Introduction This is the supplemental material for our work, ‘Tag-based Genetic Regulation for Genetic Programming’. This is not intended as a stand-alone document, but as a companion to our paper. 1.1 About our supplemental material As you may have noticed (unless you’re reading a pdf version of this), our supplemental material is hosted using GitHub pages. We compiled our data analyses and supplemental documentation into this nifty web-accessible book using bookdown. Our supplemental material includes the following: TODO 1.2 Contributing authors Alexander Lalejini Matthew Andrew Moreno Charles Ofria 1.3 Research overview 1.3.1 Abstract We introduce and experimentally demonstrate tag-based genetic regulation, a new genetic programming (GP) technique that allows evolving programs to regulate code modules. Tags are evolvable labels that provide a flexible mechanism for labeling and referring to code modules. Tag-based genetic regulation extends existing tag-based naming schemes to allow programs to ‘’promote’’ and ‘’repress’’ code modules. This extension allows evolution to form arbitrary gene regulatory networks in a program where genes are program modules and program instructions mediate regulation. We demonstrate the functionality of tag-based genetic regulation on several diagnostic tasks as well as a more challenging program synthesis problem. We find that tag-based regulation improves problem-solving performance on problems responses to particular inputs must change over time (e.g., based on local context). We also observe that our implementation of tag-based genetic regulation can impede adaptive evolution when expected outputs are not context-dependent (i.e., the correct response to a particular input remains static over time). Tag-based genetic regulation is immediately applicable to existing tag-enabled GP systems, and broadens our repertoire of techniques for evolving more dynamic programs. 1.3.2 Tag-based Referencing Tags are evolvable labels that can be mutated, and the similarity (or dissimilarity) between any two tags can be quantified (Spector et al. 2011). Tags allow for inexact addressing. A referring tag targets the tagged entity (e.g., a module) with the closest matching tag; this ensures that all possible tags are potentially valid references. Further, mutations to tags do not necessarily damage existing references. For example, mutating a referring tag will have no phenotypic effect if those mutations do not change which target tag is matched. As such, this technique allows the naming and use of modularized code fragments to incrementally co-evolve. Example of tag-based referencing. In the tag-based referencing example above, the call instruction uses tag 1001 to reference the closest-matching module (in this case, the yellow module tagged 0001). 1.3.3 Tag-based Regulation Tag-based regulation allows evolving programs to instantiate gene regulatory networks using tag-based referencing. This functionality allows programs to dynamically adjust which module is triggered by a particular call based on prior inputs. Specifically, we implemented tag-based genetic regulation in the context of a linear GP system (SignalGP); however, our approach is applicable to any tag-enabled GP system. To implement tag-based genetic regulation, we supplement the instruction set with promoter and repressor instructions that, when executed, adjust how well subsequent tag-based references match with a target module. Intuitively, promoters increase a target module’s tag-match score with subsequent references, thereby increasing its chances of being triggered; repressors have the opposite effect. When determining which module to reference in response to a call instruction, each module’s tag-match score is a function of how well the module’s tag matches the call instruction’s tag as well as the module’s regulatory value. 1.3.4 SignalGP Cartoon overview of SignalGP. SignalGP defines a way of organizing and interpreting genetic programs to afford computational evolution access to the event-driven programming paradigm. In SignalGP, program execution is signal-driven. Programs are segmented into genetic modules (or functions), and each module can be independently triggered in response to a signal. Each module associates a tag with a linear sequence of instructions. In this work, tags are represented as fixed-length bit strings. SignalGP makes the concept of events or signals explicit: all signals contain a tag and any associated data. Signals can originate exogenously (e.g, from the environment or other agents) or endogenously (e.g., self-signaling). We use tag-based referencing to determine the most appropriate function to automatically trigger in response to a signal. Signals trigger the function with the closest matching tag. For a more detailed description of the SignalGP representation, see (Lalejini and Ofria 2018). 1.3.4.1 Genetic Regulation in SignalGP In this work, we augment the SignalGP representation with genetic regulation, allowing programs to alter their responses to signals during their lifetime. We supplement the SignalGP instruction set with promotor and repressor instructions, which, when executed, adjust how well subsequent signals or internal call instructions match with a target function (instruction-level tags and tag-based referencing are used for function targeting). A simple example of how genetic regulation works (in an event-handling context) is given in the figure below. First (1), an event triggers the yellow function that, when executed, (2) promotes the red function and represses itself. Finally (3), when a subsequent signal (identical to the previous) is received, it triggers the up-regulated red function instead of the yellow function. Example of tag-based genetic regulation in SignalGP. 1.3.5 Experiments We compared the performance of regulation-enabled and regulation-disabled SignalGP on five problems: Repeated-signal Problem Contextual-signal Problem Changing-signal Problem Boolean Logic Calculator Problem (prefix notation) Boolean Logic Calculator Problem (postfix notation) The repeated-signal, contextual-signal, and prefix notation calculator problems each required programs to dynamically adjust their responses to particular inputs over time. The changing-signal and postfix notation calculator problems did not require programs to adjust responses to inputs over time. 1.3.6 Results Proof of method: we observed the evolution of programs capable of leveraging tag-based regulation to dynamically adjust module associations over time. We found that tag-based regulation improved problem-solving performance on context-dependent problems (i.e., problems in which the appropriate response to a particular input changes over time). We found that our implementation of tag-based regulation can impede adaptive evolution on problems that do not require programs to adjust responses to particular inputs over time. References "],["data-availability.html", "Chapter 2 Data Availability", " Chapter 2 Data Availability All of our experimental data is available online at (Lalejini, Moreno, and Ofria 2020). All project source code and any training/testing sets used in our experiments can be found in this project’s GitHub repository: https://github.com/amlalejini/Tag-based-Genetic-Regulation-for-LinearGP. References "],["compile-and-run-experiments-locally.html", "Chapter 3 Compile and run experiments locally 3.1 Docker 3.2 Manually", " Chapter 3 Compile and run experiments locally Here, we provide a brief guide to compiling and running our experiments. Please file an issue if something is unclear or does not work. 3.1 Docker On docker hub: https://hub.docker.com/r/amlalejini/tag-based-genetic-regulation-for-gp docker pull amlalejini/tag-based-genetic-regulation-for-gp This will create an image with all the requisite dependencies installed/downloaded and with our experiments compiled. To run the container interactively: docker run -it --entrypoint bash amlalejini/tag-based-genetic-regulation-for-gp You can exit the container at any point with ctrl-d. Inside the container, you should be at /opt/Tag-based-Genetic-Regulation-for-LinearGP/. If you ls you should see something like this (maybe not exactly): Dockerfile documents Gemfile experiments LICENSE index.Rmd Makefile media README.md requirements.txt _bookdown.yml scripts _config.yml source _output.yml style.css alt-signal-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp supplemental bool-calc-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp supplemental.bib build_book.sh supplemental_files build_exps.sh tail.Rmd chg-env-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp tests The important thing is that there should be three executables (with absurdly long names): chg-env-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp Use this to run the changing-signal problem. To generate a default configuration file, chg-env-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp --gen alt-signal-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp Use this to run the repeated-signal problem. To generate a default configuration file, alt-signal-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp --gen bool-calc-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp Use this to run any of the boolean logic calculator problems and the contextual-signal problem. To generate a default configuration file, bool-calc-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp --gen Find the exact configurations we used for our experiments here: https://github.com/amlalejini/Tag-based-Genetic-Regulation-for-LinearGP/tree/master/experiments 3.2 Manually This guide assumes an Ubuntu-flavored Linux operating system. These instructions should mostly work for MacOS; otherwise, we recommend using our Docker image or a virtual machine. Our experiments are implemented in C++, so you’ll need a modern C++ compiler capable of compiling C++17 code. E.g., I’m using: g++ (Ubuntu 10.2.0-13ubuntu1) 10.2.0 3.2.1 Get dependencies First, make a directory were we can put this project and all of its dependencies. mkdir workspace cd workspace Next, clone this repository into your new directory. git clone https://github.com/amlalejini/Tag-based-Genetic-Regulation-for-LinearGP.git Our experiments depend on the Empirical and SignalGP libraries on GitHub. Inside the workspace directory, we’ll clone SignalGP and checkout the appropriate commit. git clone https://github.com/amlalejini/SignalGP.git cd SignalGP git checkout 83d879cfdb6540862315dc454c1525ccd8054e65 cd .. Next, let’s get Empirical (also stick this in the workspace directory). git clone https://github.com/amlalejini/Empirical.git cd Empirical git checkout e72dae6490dee5caf8e5ec04a634b483d2ad4293 We’re not quite done with Empirical. We need to grab all of Empirical’s dependencies. This will install all of Empirical’s dependencies, including those needed to build its documentation/tests. make install-dependencies OR, if you don’t want all of that, instead you could do: git submodule init git submodule update If you don’t have libssl-dev, you’ll also want to install that (some of the tag-matching metrics use cryptographic hash). E.g., sudo apt-get install libssl-dev Now we should be good to compile the three executables that we used for our experiments. Inside workspace/Tag-based-Genetic-Regulation-for-LinearGP/: ./build_exps This script just sets some environment variables (e.g., to define which experiment to compile, the tag-matching metric, etc.) and runs make native. To use a different compiler (than g++), you’ll need to change CXX_nat in the makefile. This should create three executables (with absurdly long names): chg-env-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp Use this to run the changing-signal problem. To generate a default configuration file, chg-env-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp --gen alt-signal-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp Use this to run the repeated-signal problem. To generate a default configuration file, alt-signal-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp --gen bool-calc-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp Use this to run any of the boolean logic calculator problems and the contextual-signal problem. To generate a default configuration file, bool-calc-exp_tag-len-256_match-metric-streak_thresh-0_reg-exp --gen Find the exact configurations we used for our experiments here: https://github.com/amlalejini/Tag-based-Genetic-Regulation-for-LinearGP/tree/master/experiments "],["signalgp-representation.html", "Chapter 4 SignalGP representation 4.1 Memory model 4.2 Mutation operators 4.3 Instruction set", " Chapter 4 SignalGP representation Here, we give more details on how we configured SignalGP for this work, including the particular instruction sets used in each experiment. For a broad overview of SignalGP, see (Lalejini and Ofria 2018). For exact configurations used in each experiment, see respective experiment directories. 4.1 Memory model SignalGP programs have four types of memory buffers with which to carry out computations: Working (register) memory Call-local (* thread-local) memory. Memory used by the majority of computation instructions. Input memory Call-local (&amp; thread-local) memory. Read-only. This memory is used to specify function call arguments. When a function is called on a thread (i.e., a call instruction is executed), the caller’s working memory is copied into the input memory of the new call-state, which is created on top of the thread’s call stack. Programs must execute explicit instructions to read from the input memory buffer (into the working memory buffer). Output memory Call-local (&amp; thread-local) memory. Write-only. This memory is used to specify the return values of a function call. When a function returns to the previous call-state (i.e., the one just below it on the thread’s call stack), positions that were set in the output buffer are returned to the caller’s working memory buffer. Programs must execute explicit instructions to write to the output memory buffer (from the working memory buffer). Global memory This memory buffer is shared by all executing threads. Threads must use explicit instructions to access it. Memory buffers are implemented as integer to double maps. Instruction use their integer arguments to specify locations in memory. In this work, evolving programs do not have de-referencing functionality (i.e., memory pointers). 4.2 Mutation operators Single-instruction insertions Applied per instruction Single-instruction deletions Applied per instruction Single-instruction substitutions Applied per instruction Single-argument substitutions Applied per argument Slip mutations (Lalejini, Wiser, and Ofria 2017) Applied at a per-function rate. Pick two random positions in function’s instructions sequence: A and B If A &lt; B: duplicate sequence from A to B If A &gt; B: delete sequence from A to B Single-function duplications Applied per-function Single-function deletions Applied per-function Tag bit flips Applied at a per-bit rate (applies to both instruction- and function-tags) 4.3 Instruction set Abbreviations: EOP: End of program Reg: local register Reg[0] indicates the value at the register specified by an instruction’s first argument (either tag-based or numeric), Reg[1] indicates the value at the register specified by an instruction’s second argument, and Reg[2] indicates the value at the register specified by the instruction’s third argument. Reg[0], Reg[1], etc: Register 0, Register 1, etc. Input: input buffer Follows same scheme as Reg Output: output buffer Follows same scheme as Reg Global: global memory buffer Follows same scheme as Reg Arg: Instruction argument Arg[i] indicates the i’th instruction argument (an integer encoded in the genome) E.g., Arg[0] is an instruction’s first argument Instructions that would produce undefined behavior (e.g., division by zero) are treated as no operations. 4.3.1 Default Instructions I.e., instructions used across all diagnostic tasks. Instruction Arguments Used Description Nop 0 No operation Not 1 Reg[0] = !Reg[0] Inc 1 Reg[0] = Reg[0] + 1 Dec 1 Reg[0] = Reg[0] - 1 Add 3 Reg[2] = Reg[0] + Reg[1] Sub 3 Reg[2] = Reg[0] - Reg[1] Mult 3 Reg[2] = Reg[0] * Reg[1] Div 3 Reg[2] = Reg[0] / Reg[1] Mod 3 Reg[2] = Reg[0] % Reg[1] Nand 2 Reg[2] = !(Reg[0] &amp; Reg[1]) TestEqu 3 Reg[2] = Reg[0] == Reg[1] TestNEqu 3 Reg[2] = Reg[0] != Reg[1] TestLess 3 Reg[2] = Reg[0] &lt; Reg[1] TestLessEqu 3 Reg[2] = Reg[0] &lt;= Reg[1] TestGreater 3 Reg[2] = Reg[0] &gt; Reg[1] TestGreaterEqu 3 Reg[2] = Reg[0] &gt;= Reg[1] SetMem 2 Reg[0] = Arg[1] Terminal 1 Reg[0] = double value encoded by instruction tag CopyMem 2 Reg[0] = Reg[1] SwapMem 2 Swap(Reg[0], Reg[1]) InputToWorking 2 Reg[1] = Input[0] WorkingToOutput 2 Output[1] = Reg[0] If 1 If Reg[0] != 0, proceed. Otherwise skip to the next Close or EOP. While 1 While Reg[0] != 0, loop. Otherwise skip to next Close or EOP. Close 0 Indicate the end of a control block of code (e.g., loop, if). Break 0 Break out of current control flow (e.g., loop). Terminate 0 Kill thread that this instruction is executing on. Fork 0 Generate an internal signal (using this instruction’s tag) that can trigger a function to run in parallel. Call 0 Call a function, using this instruction’s tag to determine which function is called. Routine 0 Same as call, but local memory is shared. Sort of like a jump that will jump back when the routine ends. Return 0 Return from the current function call. Note that Nand performs a bitwise operation. 4.3.2 Global memory access instructions For experimental conditions without global memory access, these instructions are replaced with no-operation such that the instruction set remains a constant size regardless of experimental condition. Instruction Arguments Used Description WorkingToGlobal 2 Global[1] = Reg[0] GlobalToWorking 2 Reg[1] = Global[0] FullGlobalToWorking 0 Copy entire global memory buffer into working memory buffer FullWorkingToGlobal 0 Copy entire working memory buffer into global memory buffer Note that full buffer copies only copy registers that have been set (they do not necessarily stomp all over the entire destination buffer). 4.3.3 Regulation instructions For experimental conditions without regulation, these instructions are replaced with no-operation such that the instruction set remains a constant size regardless of experimental condition. Note that several regulation instructions have a baseline and (-) version. The (-) versions are identical to the baseline version, except that they multiply the value they are regulating with by -1. This eliminates any bias toward either up-/down-regulation. Also note that the emp::MatchBin (in the Empirical library) data structure that manages function regulation is defined in terms of tag DISTANCE, not similarity. So, decreasing function regulation values decreases the distance between potential referring tags, and thus, unintuitively, up-regulates the function. All tag-based referencing used by regulation instructions use unregulated, raw match scores. Thus, programs can still up-regulate a function that was previously ‘turned off’ with down-regulation. Instruction Arguments Used Description SetRegulator 1 Set regulation value of function (targeted with instruction tag) to Reg[0]. SetRegulator- 1 Set regulation value of function (targeted with instruction tag) to -1 * Reg[0]. SetOwnRegulator 1 Set regulation value of function (currently executing) to Reg[0]. SetOwnRegulator- 1 Set regulation value of function (currently executing) to -1 * Reg[0]. AdjRegulator 1 Regulation value of function (targeted with instruction tag) += Reg[0] AdjRegulator- 1 Regulation value of function (targeted with instruction tag) -= Reg[0] AdjOwnRegulator 1 Regulation value of function (currently executing) += Reg[0] AdjOwnRegulator- 1 Regulation value of function (currently executing) -= Reg[0] ClearRegulator 0 Clear function regulation (reset to neutral) of function targeted by instruction’s tag. ClearOwnRegulator 0 Clear function regulation (reset to neutral) of currently executing function SenseRegulator 1 Reg[0] = regulator state of function targeted by instruction tag SenseOwnRegulator 1 Reg[0] = regulator state of current function IncRegulator 0 Increment regulator state of function targeted with this instruction’s tag IncOwnRegulator 0 Increment regulator state of currently executing function DecRegulator 0 Decrement regulator state of function targeted with this instruction’s tag DecOwnRegulator 0 Decrement regulator state of the currently executing function 4.3.4 Task-specific instructions Each task as a number of response instructions added to the instruction set equal to the possible set of responses that can be expressed by a program. Each of these response instructions set a flag on the virtual hardware indicating which response the program expressed and reset all executing threads such that only function regulation and global memory contents persist. References "],["exponential-regulator.html", "Chapter 5 Exponential regulator 5.1 Analysis Dependencies 5.2 Regulator modifier equation 5.3 Regulator behavior", " Chapter 5 Exponential regulator For this work we used a simple exponential function to apply regulatory modifiers to tag-match scores (see details in paper). 5.1 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) library(RColorBrewer) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again Configuration: theme_set(theme_cowplot()) output_directory &lt;- &quot;media/&quot; 5.2 Regulator modifier equation Below is the function we use to apply regulation to module match scores. exp_base &lt;- 1.1 # Exponential regulator exp_regulator &lt;- function(raw_match, modifier, base=1.1) { return(raw_match * (base**modifier)); } 5.3 Regulator behavior Generate data to graph. We want to visualize regulated match scores as a function of raw tag match scores and module regulatory modifiers. # generate data to visualize data &lt;- expand_grid( raw_match=seq(0, 1.0, 0.01), reg_modifier=seq(-10, 10, 0.1) ) data &lt;- as.data.frame(data) data$regulated_match &lt;- mapply( exp_regulator, data$raw_match, data$reg_modifier, exp_base ) data$above_perfect &lt;- data$regulated_match &gt; 1.0 ggplot(data, aes(y=reg_modifier, x=raw_match, fill=regulated_match)) + geom_raster() + geom_hline(yintercept=0, size=1.2, color=&quot;white&quot;) + geom_hline(yintercept=0, size=1, color=&quot;black&quot;) + scale_x_continuous(name=&quot;Raw tag-match score&quot;) + scale_y_continuous(name=&quot;Module regulation modifier&quot;) + scale_fill_distiller(palette = &quot;Spectral&quot;) + theme( legend.position = &quot;top&quot;, legend.key.width=unit(2, &#39;cm&#39;) ) + ggsave( paste0(output_directory, &quot;exp-reg-match.png&quot;), width=10, height=10 ) Does a given raw match + regulatory modifier beat a perfect match (with no regulation)? ggplot(data, aes(y=reg_modifier, x=raw_match, fill=above_perfect)) + geom_tile() + ggsave( paste0(output_directory, &quot;exp-reg-match-above-perfect.png&quot;), width=10, height=10 ) "],["changing-signal-problem-analysis.html", "Chapter 6 Changing-signal problem analysis 6.1 Overview 6.2 Analysis Dependencies 6.3 Setup 6.4 Does regulation hinder the evolution of successful genotypes?", " Chapter 6 Changing-signal problem analysis Here, we give an overview of the changing-signal diagnostic problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 6.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 env_complexities &lt;- c(16) # Settings for statistical analyses. alpha &lt;- 0.05 correction_method &lt;- &quot;bonferroni&quot; # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-11-chg-sig/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis The changing-signal task requires programs to express a unique response for each of \\(K\\) distinct environmental signals (i.e., each signal has a distinct tag); the figure below is given as an example. Because signals are distinct, programs do not need to alter their responses to particular signals over time. Instead, programs may ‘hardware’ each of the \\(K\\) possible responses to the appropriate environmental signal. However, environmental signals are presented in a random order; thus, the correct order of responses will vary and cannot be hardcoded. As in the repeated signal task, programs respond by executing one of \\(K\\) response instructions. Otherwise, evaluation (and fitness assignment) on the changing-signal task mirrors that of the repeated signal task. Requiring programs to express a distinct instruction in response to each environmental signal represents programs having to perform distinct behaviors. We afforded programs 128 time steps to express the appropriate response after receiving an environmental signal. Once the allotted time to respond expires or the program expresses any response, the program’s threads of execution are reset, resulting in a loss of all thread-local memory. Only the contents of a program’s global memory and each function’s regulatory state persist. The environment then produces the next signal (distinct from all previous signals) to which the program may respond. A program’s fitness is equal to the number of correct responses expressed during evaluation. We evolved populations of 1000 SignalGP programs to solve the changing-signal task at \\(K=16\\) (where \\(K\\) denotes the number of environmental signals). We evolved populations for 10^{4} generations or until an program capable of achieving a perfect score during task evaluation (i.e., able to express the appropriate response to each of the \\(K\\) signals) evolved. We ran 200 replicate populations (each with a distinct random number seed) of each of the following experimental conditions: a regulation-enabled treatment where programs have access to genetic regulation. a regulation-disabled treatment where programs do not have access to genetic regulation. Note this task does not require programs to shift their response to particular signals over time, and as such, genetic regulation is unnecessary. Further, because programs experience environmental inputs in a random order, erroneous genetic regulation can manifest as cryptic variation. For example, non-adaptive down-regulation of a particular response function may be neutral given one sequence of environmental signals, but may be deleterious in another. We expected regulation-enabled SignalGP to exhibit non-adaptive plasticity, potentially resulting in slower adaptation and non-general solutions. 6.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 6.3 Setup Load data, initial data cleanup, configure some global settings. # Load data file data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # For convenience, create a data set with only solutions # Filter data to include only replicates labeled as solutions sol_data &lt;- filter( data, solution==&quot;1&quot; ) # A lookup table for task complexities task_label_lu &lt;- c( &quot;2&quot; = &quot;2-signal task&quot;, &quot;4&quot; = &quot;4-signal task&quot;, &quot;8&quot; = &quot;8-signal task&quot;, &quot;16&quot; = &quot;16-signal task&quot;, &quot;32&quot; =&quot;32-signal task&quot; ) # Configure our default graphing theme theme_set(theme_cowplot()) 6.4 Does regulation hinder the evolution of successful genotypes? Here, we look at the number of solutions evolved under regulation-enabled and regulation-disabled conditions. A program is categorized as a ‘solution’ if it can correctly respond to each of the \\(K\\) environmental signals during evaluation. # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot( sol_data, aes(x=condition, fill=condition) ) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;,&quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates (/200)&quot;) + theme(legend.position = &quot;none&quot;) + ggtitle(&quot;Successful replicates&quot;) Programs capable of achieving a perfect score on the changing-signal task (for a given sequence of environment signals) evolve in all 200 replicates of each condition (i.e., with and without access to genetic regulation). These programs, however, do not necessarily generalize across all possible sequences of environmental signals. 6.4.1 Does access to regulation slow adaptation? I.e., did successful regulation-enabled programs take longer (more generations) to evolve than those evolved in the regulation-disabled treatment? ggplot( sol_data, aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( aes(y = update, color = condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;,&quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous( name=&quot;Generation first solution evolved \\n(log scale)&quot;, ) + guides(fill = FALSE) + guides(color = FALSE) print(wilcox.test(formula=update~condition, data=sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 22188, p-value = 0.05845 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -3.860236e-05 1.000000e+01 ## sample estimates: ## difference in location ## 5.000013 The difference in the number of generations before a solution arises is not significantly different. 6.4.2 Do they generalize? Note that solutions may or may not generalize beyond the sequence of environmental signals on which they achieved a perfect score (and were thus categorized as a ‘solution’). We re-evaluated each ‘solution’ on a random sample of 5000 sequences of environmental signals to test for generalization. We deem programs as having successfully generalized only if they responded correctly in all 5000 tests. To see if regulation is preventing some regulation-enabled solutions from generalizing, we test generalization for regulation-enabled solutions with their regulation faculties knocked out (i.e., regulation instructions replaced with no-operations). # Grab count data to make bar plot life easier num_solutions_reg &lt;- length(filter(data, condition==&quot;both&quot; &amp; solution==&quot;1&quot;)$SEED) num_generalize_reg &lt;- length(filter(data, condition==&quot;both&quot; &amp; all_solution==&quot;1&quot;)$SEED) num_generalize_ko_reg &lt;- length(filter(data, condition==&quot;both&quot; &amp; all_solution_ko_reg==&quot;1&quot;)$SEED) num_generalize_mem &lt;- length(filter(data, condition==&quot;memory&quot; &amp; all_solution==&quot;1&quot;)$SEED) sol_cnts &lt;- data.frame(x=1:3) sol_cnts$type &lt;- c(&quot;reg_generalize&quot;, &quot;reg_generalize_ko_reg&quot;, &quot;mem_generalize&quot;) sol_cnts$val &lt;- c(num_generalize_reg, num_generalize_ko_reg, num_generalize_mem) ggplot( sol_cnts, aes(x=type, y=val, fill=type) ) + geom_bar(stat=&quot;identity&quot;) + geom_text( aes(label=val), stat=&quot;identity&quot;, position=position_dodge(0.75), vjust=-0.01 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=c( &quot;mem_generalize&quot;, &quot;reg_generalize&quot;, &quot;reg_generalize_ko_reg&quot; ), labels=c( &quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;, &quot;Regulation-\\nenabled\\n(reg. KO)&quot; ) ) + scale_y_continuous( name=&quot;# of solutions that generalize&quot;, limits=c(0, 210), breaks=seq(0,200,50) ) + theme( legend.position=&quot;none&quot;, axis.text.x = element_text(size=10) ) + ggsave(paste0(working_directory, &quot;imgs/chg-env-16-generalization.png&quot;), width=4,height=4) All regulation-disabled programs successfully generalized. table &lt;- matrix(c(num_generalize_reg, num_generalize_mem, 200 - num_generalize_reg, 200 - num_generalize_mem), nrow=2) rownames(table) &lt;- c(&quot;reg-augmented&quot;, &quot;reg-disabled&quot;) colnames(table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(table) ## success fail ## reg-augmented 182 18 ## reg-disabled 200 0 fisher.test(table) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: table ## p-value = 5.113e-06 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.0000000 0.2115509 ## sample estimates: ## odds ratio ## 0 The difference in number of generalizing solutions between regulation-enabled and regulation-disabled conditions is statistically significant (Fisher’s exact test). Moreover, 5 of the 18 non-generalizing programs generalize when we knockout genetic regulation. Upon close inspection, the other 13 non-general programs relied on genetic regulation to achieve initial success but failed to generalize to arbitrary environment signal sequences. "],["repeated-signal-problem-analysis.html", "Chapter 7 Repeated-signal problem analysis 7.1 Overview 7.2 Analysis Dependencies 7.3 Setup 7.4 Problem-solving success 7.5 How many generations elapse before solutions evolve? 7.6 Teasing apart evolved strategies 7.7 Case study: visualizing regulation in an evolved program", " Chapter 7 Repeated-signal problem analysis Here, we give an overview of the repeated-signal diagnostic problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 7.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 env_complexities &lt;- c(2, 4, 8, 16) # Settings for statistical analyses. alpha &lt;- 0.05 correction_method &lt;- &quot;bonferroni&quot; # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-25-rep-sig/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis The repeated-signal problem requires programs to output the appropriate (distinct) response to a single environmental signal each of the \\(K\\) times the signal is repeated. Programs output responses by executing one of \\(K\\) response instructions. For example, if a program receives two signals from the environment during evaluation (i.e., \\(K=2\\)), the program should execute Response-1 after the first signal and Response-2 after the second signal. We afford programs 128 time steps to respond to each environmental signal. Once the allotted time expires or the program executes any response, the program’s threads of execution are reset, resulting in a loss of all thread-local memory; only the contents of the global memory buffer and each program module’s regulatory state persist. The environment then produces the next signal (identical to each previous environmental signal) to which the program may respond. A program must use the global memory buffer or genetic regulation to correctly shift its response to each subsequent environmental signal. Evaluation continues in this way until the program correctly responds to each of the \\(K\\) environmental signals or until the program executes an incorrect response. A program’s fitness equals the number of correct responses given during evaluation, and a program is considered a solution if it correctly responds to each of the \\(K\\) environmental signals. 7.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(reshape2) library(cowplot) library(viridis) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 7.3 Setup Load data, initial data cleanup, configure some global settings. max_fit_org_data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs_noprogram.csv&quot;) reg_network_data_loc &lt;- paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;) inst_exec_data_loc &lt;- paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;) ####### Load max fit program data ####### max_fit_org_data &lt;- read.csv(max_fit_org_data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). max_fit_org_data$matchbin_thresh &lt;- factor( max_fit_org_data$matchbin_thresh, levels=c(0, 25, 50, 75) ) max_fit_org_data$NUM_SIGNAL_RESPONSES &lt;- factor( max_fit_org_data$NUM_SIGNAL_RESPONSES, levels=c(2, 4, 8, 16, 32) ) max_fit_org_data$NUM_ENV_CYCLES &lt;- factor( max_fit_org_data$NUM_ENV_CYCLES, levels=c(2, 4, 8, 16, 32) ) max_fit_org_data$TAG_LEN &lt;- factor( max_fit_org_data$TAG_LEN, levels=c(32, 64, 128, 256) ) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. max_fit_org_data$condition &lt;- mapply( get_con, max_fit_org_data$USE_FUNC_REGULATION, max_fit_org_data$USE_GLOBAL_MEMORY ) max_fit_org_data$condition &lt;- factor( max_fit_org_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Does this program rely on a stochastic strategy? max_fit_org_data$stochastic &lt;- 1 - max_fit_org_data$consistent max_fit_org_data$stochastic &lt;- factor( max_fit_org_data$stochastic, levels=c(0, 1) ) # Filter data to include only runs from regulation-enabled (&#39;both&#39;) and regulation-disabled (&#39;memory&#39;) conditions max_fit_org_data &lt;- filter(max_fit_org_data, condition %in% c(&quot;both&quot;, &quot;memory&quot;)) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(max_fit_org_data, solution==&quot;1&quot;) # Label solution strategies get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). sol_data$strategy &lt;- mapply( get_strategy, sol_data$relies_on_regulation, sol_data$relies_on_global_memory ) sol_data$strategy &lt;- factor( sol_data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) ####### Load network data ####### reg_network_data &lt;- read.csv(reg_network_data_loc, na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% max_fit_org_data$SEED) # Make a lookup function to get each run&#39;s environment complexity level. get_num_sig_resps &lt;- function(seed) { return(filter(max_fit_org_data, SEED==seed)$NUM_SIGNAL_RESPONSES) } reg_network_data$NUM_SIGNAL_RESPONSES &lt;- mapply( get_num_sig_resps, reg_network_data$run_id ) reg_network_data$NUM_SIGNAL_RESPONSES &lt;- factor(reg_network_data$NUM_SIGNAL_RESPONSES) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(inst_exec_data_loc, na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$NUM_SIGNAL_RESPONSES &lt;- factor( inst_exec_data$NUM_SIGNAL_RESPONSES, levels=c(2, 4, 8, 16, 32) ) inst_exec_data$NUM_ENV_CYCLES &lt;- factor( inst_exec_data$NUM_ENV_CYCLES, levels=c(2, 4, 8, 16, 32) ) # Labels for each label_lu &lt;- c( &quot;2&quot; = &quot;2-signal task&quot;, &quot;4&quot; = &quot;4-signal task&quot;, &quot;8&quot; = &quot;8-signal task&quot;, &quot;16&quot; = &quot;16-signal task&quot;, &quot;32&quot; =&quot;32-signal task&quot; ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 7.4 Problem-solving success We expected populations with access to genetic regulation to be more successful on the repeated-signal task than those evolved without access to genetic regulation. Further, we expected the success differential to increase with problem difficulty. We can look at (1) the number of successful replicates (i.e., replicates in which a program capable of perfectly solving the repeated signal task evolved) per condition and (2) the scores of the highest-fitness program evolved in each replicate. 7.4.1 Number of successful replicates by condition Note that a program is categorized as a ‘solution’ only if it can correctly respond to each of repetition of the environment signal. # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot( sol_data, aes(x=condition, fill=condition) ) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_y_continuous( name=&quot;# evolved solutions&quot;, breaks=seq(0, replicates, 50), limits=c(0, replicates+2) ) + scale_fill_discrete( name=&quot;Condition:&quot;, limits=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( name=&quot;Condition&quot;, limits=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + ggtitle(&quot;Solution Counts&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-solultion-cnts.png&quot;), width=8, height=4 ) We confirmed that each difficulty level of the repeated-signal problem is solvable without regulation using hand-coded SignalGP programs. We use a Fisher’s exact test to determine if there are significant differences (p &lt; 0.05) between the numbers of regulation-enabled versus regulation-disabled solutions for each problem difficulty. # This code chunk is sort of a monster to have things print out all pretty-like in the knitted HTML document. # For each environment complexity level, do a fisher&#39;s exact test and print results. for (env in env_complexities) { env_data &lt;- filter(max_fit_org_data, NUM_SIGNAL_RESPONSES==env) cat(&quot;#### &quot;, paste0(env, &quot;-signal task&quot;), &quot; - statistical analysis of solution counts \\n&quot;) # Extract successes/fails for each condition. mem_success_cnt &lt;- nrow(filter(env_data, solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) mem_fail_cnt &lt;- nrow(filter(env_data, condition==&quot;memory&quot;)) - mem_success_cnt both_success_cnt &lt;- nrow(filter(env_data, solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) both_fail_cnt &lt;- nrow(filter(env_data, condition==&quot;both&quot;)) - both_success_cnt # Regulation-disabled vs regulation-enabled mem_sgp_table &lt;- matrix(c(both_success_cnt, mem_success_cnt, both_fail_cnt, mem_fail_cnt), nrow=2) rownames(mem_sgp_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(mem_sgp_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) mem_sgp_fishers &lt;- fisher.test(mem_sgp_table) cat(&quot;\\n&quot;) cat(&quot;Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): \\n&quot;) cat(&quot;```\\n&quot;) print(mem_sgp_table) print(mem_sgp_fishers) cat(&quot;```\\n&quot;) cat(&quot;\\n&quot;) } 7.4.1.1 2-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 200 0 reg-disabled 137 63 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 23.54182 Inf sample estimates: odds ratio Inf 7.4.1.2 4-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 200 0 reg-disabled 8 192 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 953.6049 Inf sample estimates: odds ratio Inf 7.4.1.3 8-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 198 2 reg-disabled 0 200 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 2409.412 Inf sample estimates: odds ratio Inf 7.4.1.4 16-signal task - statistical analysis of solution counts Regulation-enabled SignalGP vs. regulation-disabled SignalGP (original version of SignalGP): success fail reg-enabled 74 126 reg-disabled 0 200 Fisher&#39;s Exact Test for Count Data data: mem_sgp_table p-value &lt; 2.2e-16 alternative hypothesis: true odds ratio is not equal to 1 95 percent confidence interval: 30.12902 Inf sample estimates: odds ratio Inf 7.4.2 Aggregate fitness scores by condition Here, we visualize the raw task scores for the highest-fitness program from each run across all environments/conditions. ggplot( max_fit_org_data, aes(x=condition, y=score, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + ylab(&quot;Score (# correct responses)&quot;) + scale_color_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, scales=&quot;free_y&quot;, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) + ggtitle(&quot;Task Scores&quot;) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-scores.png&quot;), width=16, height=8 ) 7.5 How many generations elapse before solutions evolve? Do some conditions lead to the evolution of solutions in fewer generations than other conditions? Here, we compare the generation at which solutions arise (only at difficulty levels where regulation-disabled solutions evovled). ggplot( data = filter(sol_data, NUM_SIGNAL_RESPONSES %in% c(2, 4)), aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-enabled&quot;) ) + scale_y_continuous( name=&quot;Generation first solution evolved \\n(log scale)&quot;, limits=c(0, generations), breaks=c(0, 10, 100, 1000, 10000), trans=&quot;pseudo_log&quot; ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;./imgs/repeated-signal-solve-time-cloud.png&quot;), width=5, height=4 ) ## Warning: Removed 90 rows containing missing values (geom_point). ## Warning: Removed 90 rows containing missing values (geom_point). 7.5.1 Two-signal task - statistical analysis We compare the time to solution using a Wilcoxon rank-sum test. env_2_sol_data &lt;- filter( sol_data, NUM_SIGNAL_RESPONSES==2 ) print(wilcox.test(formula=update~condition, data=env_2_sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 24940, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 6.000004 11.000006 ## sample estimates: ## difference in location ## 7.999963 7.5.2 Four-signal task - statistical analysis We compare the time to solution using a Wilcoxon rank-sum test. env_4_sol_data &lt;- filter( sol_data, NUM_SIGNAL_RESPONSES==4 ) print(wilcox.test(formula=update~condition, data=env_4_sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 1456, p-value = 8.603e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 173 738 ## sample estimates: ## difference in location ## 319.636 7.6 Teasing apart evolved strategies We analyzed: mechanisms underlying capacity to adjust responses to input signals (using knockout experiments) whether programs used stochasticity as part of their strategy instruction execution traces 7.6.1 Do solutions rely on genetic regulation or global memory access to dynamically adjust responses? Here, we take a closer at the strategies employed by solutions evolved across environment complexities. For each evolved solution, we independently knocked out (disabled) tag-based regulation and global memory access, and we measured the fitness effects knocking each out. If a knockout resulted in a decrease in fitness, we labeled that program as relying on that functionality (global memory or genetic regulation) for success. The graph(s) below gives the proportion of solutions that rely exclusively on regulation, exclusively on global memory, on both global memory and regulation, and on neither functionality. Proportions as stacked bar chart: ggplot( data=sol_data, mapping=aes(x=NUM_SIGNAL_RESPONSES, fill=strategy) ) + geom_bar( position=&quot;fill&quot; ) + ylab(&quot;# of Solutions&quot;) + xlab(&quot;Environment Complexity&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c(&quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot;), labels=c(&quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot;) ) + facet_wrap(~condition) As fun donuts(?!): # https://www.r-graph-gallery.com/128-ring-or-donut-plot.html donut_data &lt;- data.frame( env=character(), count=numeric(), category=character() ) for (env in env_complexities) { env_donut_data &lt;- data.frame( env=c(env, env, env, env), count=c( nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use neither&quot;)), nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use memory&quot;)), nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use regulation&quot;)), nrow(filter(sol_data, condition==&quot;both&quot; &amp; NUM_SIGNAL_RESPONSES==env &amp; strategy==&quot;use both&quot;)) ), category=c(&quot;neither&quot;, &quot;memory&quot;, &quot;regulation&quot;, &quot;both&quot;) ) env_donut_data &lt;- filter(env_donut_data, count &gt; 0) env_donut_data$fraction &lt;- env_donut_data$count / sum(env_donut_data$count) env_donut_data$ymax &lt;- cumsum(env_donut_data$fraction) env_donut_data$ymin &lt;- c(0, head(env_donut_data$ymax, n=-1)) env_donut_data$labelPosition &lt;- (env_donut_data$ymax + env_donut_data$ymin) / 2 env_donut_data$label &lt;- paste0(env_donut_data$count) donut_data&lt;-rbind(donut_data, env_donut_data) } ggplot( donut_data, aes(ymax=ymax, ymin=ymin, xmax=4, xmin=3, fill=category) ) + geom_rect() + geom_label( x=4, aes(y=labelPosition, label=label), size=4, show.legend = FALSE) + coord_polar(theta=&quot;y&quot;) + xlim(c(-1, 4)) + scale_fill_discrete( name=&quot;Strategy:&quot;, limits=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use both&quot;)) + theme_void() + theme(legend.position = &quot;bottom&quot;) + facet_wrap( ~env, nrow=1, labeller=labeller(env=label_lu) ) We can see that in conditions where programs have access to regulation, evolved solutions generally rely on regulation to adjust their responses to input signals. In conditions where memory is the only mechanism for solving the repeated-signal task, we see that all evolved solutions rely exclusively on global memory access for adjusting responses to input signals. 7.6.2 What forms of genetic regulation do evolved programs rely on? We used two approaches to tease apart forms of genetic regulation that evolved SignalGP programs rely on: We traced program execution step-by-step (including each function’s regulatory state) during evaluation on the repeated signal task and extracted regulatory interactions between executing functions as a directed graph. We draw a directed edge from function A to function B if B’s regulatory state changes while A is executing. We label each edge as up- or down-regulation. The distribution of edge types in these graphs hints at what strategy the program is using. We independently knockout up-regulation and down-regulation and record the fitness of knockout-variants. If fitness decreases when a target functionality is knocked out, we categorize the program as relying on that functionality. Note that the knockout data more directly indicates which forms of regulation a program relies on, as the gene regulation networks may include neutral and non-adaptive regulatory interactions. 7.6.2.1 Gene regulatory network edges Let’s only look at programs that solved the repeated-signal task and rely on regulation. First, total edges as a function of problem difficulty. relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg ), aes(x=NUM_SIGNAL_RESPONSES, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Get seeds (run ids) of replicates that rely on regulation and are a solution. melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot( melted_network_data, aes(x=NUM_SIGNAL_RESPONSES, y=reg_edges_cnt, color=reg_edge_type) ) + geom_boxplot() + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_color_discrete( name=&quot;Edge type:&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/repeated-signal-regulation-edge-types.png&quot;), width=4, height=3 ) for (env in env_complexities) { print(paste(&quot;Environment&quot;, env)) print(paste0(&quot; Median repressing edges: &quot;, median(filter(melted_network_data, NUM_SIGNAL_RESPONSES==env &amp; reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt))) print(paste0(&quot; Median promoting edges: &quot;, median(filter(melted_network_data, NUM_SIGNAL_RESPONSES==env &amp; reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt))) wt &lt;- wilcox.test( formula=reg_edges_cnt ~ reg_edge_type, data=filter(melted_network_data, NUM_SIGNAL_RESPONSES==env), exact=FALSE, conf.int=TRUE ) print(wt) } ## [1] &quot;Environment 2&quot; ## [1] &quot; Median repressing edges: 3&quot; ## [1] &quot; Median promoting edges: 2&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 21990, p-value = 8.308e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 6.294052e-06 1.000039e+00 ## sample estimates: ## difference in location ## 0.9999429 ## ## [1] &quot;Environment 4&quot; ## [1] &quot; Median repressing edges: 6&quot; ## [1] &quot; Median promoting edges: 3&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 30971, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 2.999916 3.999984 ## sample estimates: ## difference in location ## 3.000027 ## ## [1] &quot;Environment 8&quot; ## [1] &quot; Median repressing edges: 9&quot; ## [1] &quot; Median promoting edges: 3&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 34138, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 5.000045 6.000012 ## sample estimates: ## difference in location ## 5.999952 ## ## [1] &quot;Environment 16&quot; ## [1] &quot; Median repressing edges: 16&quot; ## [1] &quot; Median promoting edges: 4&quot; ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 4984, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 11.00002 13.00001 ## sample estimates: ## difference in location ## 12.00003 7.6.2.2 Knockout experiments Do successful programs rely on: neither up- nor down-regulation? either up- or down-regulation interchangeably? only on down-regulation? only on up-regulation? # Limit the genotypes we&#39;re looking at to just solutions from the &#39;both&#39; and &#39;regulation&#39; conditions. relies_on_reg_orgs &lt;- filter( max_fit_org_data, solution==&quot;1&quot; &amp; relies_on_regulation==&quot;1&quot; ) Note that there are 661 total programs represented in the graphs below. # Data processing/clean up get_reg_relies_on &lt;- function(uses_down, uses_up, uses_reg) { if (uses_down == &quot;0&quot; &amp;&amp; uses_up == &quot;0&quot; &amp;&amp; uses_reg == &quot;0&quot;) { return(&quot;neither&quot;) } else if (uses_down == &quot;0&quot; &amp;&amp; uses_up == &quot;0&quot; &amp;&amp; uses_reg == &quot;1&quot;) { return(&quot;either&quot;) } else if (uses_down == &quot;0&quot; &amp;&amp; uses_up == &quot;1&quot;) { return(&quot;up-regulation-only&quot;) } else if (uses_down == &quot;1&quot; &amp;&amp; uses_up == &quot;0&quot;) { return(&quot;down-regulation-only&quot;) } else if (uses_down == &quot;1&quot; &amp;&amp; uses_up == &quot;1&quot;) { return(&quot;up-and-down-regulation&quot;) } else { return(&quot;UNKNOWN&quot;) } } relies_on_reg_orgs$regulation_type_usage &lt;- mapply( get_reg_relies_on, relies_on_reg_orgs$relies_on_down_reg, relies_on_reg_orgs$relies_on_up_reg, relies_on_reg_orgs$relies_on_regulation ) relies_on_reg_orgs$regulation_type_usage &lt;- factor( relies_on_reg_orgs$regulation_type_usage, levels=c( &quot;neither&quot;, &quot;either&quot;, &quot;up-regulation-only&quot;, &quot;down-regulation-only&quot;, &quot;up-and-down-regulation&quot; ) ) 7.6.2.2.1 Regulation usage by environment ggplot(relies_on_reg_orgs, aes(x=regulation_type_usage, fill=regulation_type_usage)) + geom_bar() + geom_text( stat=&quot;count&quot;, aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Regulation Usage&quot;, limits=c( &quot;neither&quot;, &quot;either&quot;, &quot;up-regulation-only&quot;, &quot;down-regulation-only&quot;, &quot;up-and-down-regulation&quot; ), labels=c( &quot;None&quot;, &quot;Either&quot;, &quot;Up\\n(only)&quot;, &quot;Down\\n(only)&quot;, &quot;Both&quot; ) ) + facet_wrap(~NUM_SIGNAL_RESPONSES) + theme(legend.position=&quot;none&quot;) + ggtitle(&quot;Regulation usage by environment&quot;) + ggsave( paste0(working_directory, &quot;imgs/rst-reg-usage-by-env.png&quot;), width=8, height=6 ) 7.6.2.2.2 Regulation usage across all environments ggplot(relies_on_reg_orgs, aes(x=regulation_type_usage, fill=regulation_type_usage)) + geom_bar() + geom_text( stat=&quot;count&quot;, aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Regulation Usage&quot;, limits=c( &quot;neither&quot;, &quot;either&quot;, &quot;up-regulation-only&quot;, &quot;down-regulation-only&quot;, &quot;up-and-down-regulation&quot; ), labels=c( &quot;None&quot;, &quot;Either&quot;, &quot;Up\\n(only)&quot;, &quot;Down\\n(only)&quot;, &quot;Both&quot; ) ) + theme(legend.position=&quot;none&quot;) + ggtitle(&quot;Regulation usage across all environments&quot;) + ggsave( paste0(working_directory, &quot;imgs/rst-reg-usage-total.png&quot;), width=8, height=6 ) 7.6.3 Are evolved programs relying on stochastic strategies? To confirm that evolved programs are not relying on stochastic approaches to solve the repeated signal task, we tested the most fit individual from each replicate at the end of each run three times. If program’s behavior was not identical across each of the three trials, we labeled is as using a stochastic strategy. ggplot( max_fit_org_data, aes(x=condition, fill=stochastic)) + geom_bar() + ggtitle(&quot;Stochastic Strategies?&quot;) + ylab(&quot;# Replicates&quot;) + ylim(0, replicates) + scale_fill_discrete( name=&quot;Strategy&quot;, limits=c(0, 1), labels=c(&quot;Deterministic&quot;, &quot;Stochastic&quot;) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + facet_wrap( ~NUM_SIGNAL_RESPONSES, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? We see no evidence of evolved programs relying on stochastic strategies to solve the repeated signal task: all programs responded consistently across trials. Note, this is unsurprising, as we did not give programs access to instructions capable of generating random values and ensured that the version of SignalGP virtual hardware used in this work operated in a deterministic manner. 7.6.4 Program instruction execution traces 7.6.4.1 Execution time How many time steps do evolved programs use to solve the repeated-signal task? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_color_discrete( name=&quot;Condition: &quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Two-signal task: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==2), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 23102, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 38.00000 51.99997 ## sample estimates: ## difference in location ## 44.99995 Four-signal task: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==4), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 1494.5, p-value = 3.214e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 67.99998 112.00000 ## sample estimates: ## difference in location ## 89.00002 7.6.4.2 Distribution of executed instruction types Here, we look at the distribution of instruction types that programs execute during evaluation. For this work, we are primarily interested in the proportions of control flow instructions executed. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_color_discrete( name=&quot;Condition: &quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;D&quot;, &quot;E&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + facet_wrap( ~ NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Two-signal task statistical comparison: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==2), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 19580, p-value = 2.118e-11 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.02022011 0.03692075 ## sample estimates: ## difference in location ## 0.02817524 Four-signal task statistical comparison: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data, NUM_SIGNAL_RESPONSES==4), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 1292.5, p-value = 0.003185 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.01577416 0.06398521 ## sample estimates: ## difference in location ## 0.04051067 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition: &quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled (D)&quot;, &quot;Regulation-enabled (E)&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + facet_wrap( ~NUM_SIGNAL_RESPONSES, nrow=1, labeller=labeller(NUM_SIGNAL_RESPONSES=label_lu) ) + coord_flip() + theme( legend.position=&quot;bottom&quot; ) 7.7 Case study: visualizing regulation in an evolved program Let’s take a closer look at the behavioral/regulatory profile of a representative program that solves the four-signal version of the repeated signal task. trace_id &lt;- 20203 Specifically, we’ll be looking at the solution evolved in run id 2.0203^{4}. 7.7.1 Data wrangling case_study_info &lt;- read.csv( paste0(working_directory, &quot;data/max_fit_orgs_noprogram.csv&quot;), na.strings=&quot;NONE&quot; ) case_study_info &lt;- filter( case_study_info, SEED==trace_id ) # Extract relevant information about solution of interest. num_envs &lt;- case_study_info$NUM_SIGNAL_RESPONSES score &lt;- case_study_info$score is_sol &lt;- case_study_info$solution num_modules &lt;- case_study_info$num_modules # Load trace file associated with this solution. trace_file &lt;- paste0(working_directory, &quot;data/reg-traces/trace-reg_update-10000_run-id-&quot;, trace_id, &quot;.csv&quot;) trace_data &lt;- read.csv(trace_file, na.strings=&quot;NONE&quot;) trace_data$similarity_score &lt;- 1 - trace_data$match_score # Data cleanup/summarizing trace_data$triggered &lt;- (trace_data$env_signal_closest_match == trace_data$module_id) &amp; (trace_data$cpu_step == &quot;0&quot;) trace_data$is_running &lt;- trace_data$is_running &gt; 0 | trace_data$triggered | trace_data$is_cur_responding_function == &quot;1&quot; # Extract which modules responded and when response_time_steps &lt;- levels(factor(filter(trace_data, is_cur_responding_function==&quot;1&quot;)$time_step)) responses_by_env_update &lt;- list() for (t in response_time_steps) { env_update &lt;- levels(factor(filter(trace_data, time_step==t)$env_cycle)) if (env_update %in% names(responses_by_env_update)) { if (as.integer(t) &gt; as.integer(responses_by_env_update[env_update])) { responses_by_env_update[env_update] = t } } else { responses_by_env_update[env_update] = t } } # Build a list of modules that were triggered &amp; those that responded to a signal triggered_ids &lt;- levels(factor(filter(trace_data, triggered==TRUE)$module_id)) response_ids &lt;- levels(factor(filter(trace_data, is_cur_responding_function==&quot;1&quot;)$module_id)) trace_data$is_ever_active &lt;- trace_data$is_ever_active==&quot;1&quot; | trace_data$is_running | trace_data$module_id %in% triggered_ids | trace_data$module_id %in% response_ids trace_data$is_cur_responding_function &lt;- trace_data$is_cur_responding_function==&quot;1&quot; &amp; trace_data$time_step %in% responses_by_env_update # function to categorize each regulatory state as promoted, neutral, or repressed # remember, the regulatory states in our data file operate with tag DISTANCE in mind # as opposed to tag similarity, so: promotion =&gt; reg &lt; 0, repression =&gt; reg &gt; 0 categorize_reg_state &lt;- function(reg_state) { if (reg_state == 0) { return(&quot;neutral&quot;) } else if (reg_state &lt; 0) { return(&quot;promoted&quot;) } else if (reg_state &gt; 0) { return(&quot;repressed&quot;) } else { return(&quot;unknown&quot;) } } trace_data$regulator_state_simplified &lt;- mapply( categorize_reg_state, trace_data$regulator_state ) # Omit all in-active rows # Extract only rows that correspond with modules that were active during evaluation. active_data &lt;- filter(trace_data, is_ever_active==TRUE) # Do some work to have module ids appear in a nice order along axis. active_module_ids &lt;- levels(factor(active_data$module_id)) active_module_ids &lt;- as.integer(active_module_ids) module_id_map &lt;- as.data.frame(active_module_ids) module_id_map$order &lt;- order(module_id_map$active_module_ids) - 1 get_module_x_pos &lt;- function(module_id) { return(filter(module_id_map, active_module_ids==module_id)$order) } active_data$mod_id_x_pos &lt;- mapply(get_module_x_pos, active_data$module_id) 7.7.2 Function regulation over time First, let’s omit all non-active funcitons. Vertical orientation: out_name &lt;- paste0( working_directory, &quot;imgs/case-study-trace-id-&quot;, trace_id, &quot;-regulator-state-vertical.pdf&quot; ) ggplot( active_data, aes(x=mod_id_x_pos, y=time_step, fill=regulator_state_simplified) ) + scale_fill_viridis( name=&quot;Regulation:&quot;, limits=c( &quot;promoted&quot;, &quot;neutral&quot;, &quot;repressed&quot; ), labels=c( &quot;+&quot;, &quot;\\u00F8&quot;, &quot;-&quot; ), discrete=TRUE, direction=-1 ) + scale_x_discrete( name=&quot;Function ID&quot;, limits=seq(0, length(active_module_ids)-1, 1), labels=active_module_ids ) + scale_y_discrete( name=&quot;Time Step&quot;, limits=seq(0, 30, 5) ) + # Background tile color geom_tile( color=&quot;white&quot;, size=0.2, width=1, height=1, alpha=0.75 ) + # Highlight actively running functions geom_tile( data=filter(active_data, is_running==TRUE | triggered==TRUE), color=&quot;black&quot;, size=0.8, width=1, height=1 ) + # Environment delimiters geom_hline( yintercept=filter(active_data, cpu_step==0)$time_step - 0.5, size=1.25, color=&quot;black&quot; ) + # Draw points on triggered modules geom_point( data=filter(active_data, triggered==TRUE), shape=8, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + geom_point( data=filter(active_data, is_cur_responding_function==TRUE), shape=21, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + theme( legend.position = &quot;top&quot;, legend.text = element_text(size=9), legend.title=element_text(size=8), axis.text.y = element_text(size=8), axis.title.y = element_text(size=8), axis.text.x = element_text(size=8), axis.title.x = element_text(size=8), plot.title = element_text(hjust = 0.5) ) + ggsave( out_name, height=3.5, width=2.25 ) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? Horizontal orientation: out_name &lt;- paste0(working_directory, &quot;imgs/case-study-trace-id-&quot;,trace_id,&quot;-regulator-state-horizontal.pdf&quot;) ggplot(active_data, aes(x=mod_id_x_pos, y=time_step, fill=regulator_state_simplified)) + scale_fill_viridis( name=&quot;Regulation:&quot;, limits=c( &quot;promoted&quot;, &quot;neutral&quot;, &quot;repressed&quot; ), labels=c( &quot;+&quot;, &quot;\\u00F8&quot;, &quot;-&quot; ), discrete=TRUE, direction=-1 ) + scale_x_discrete( name=&quot;Function ID&quot;, limits=seq(0, length(active_module_ids)-1, 1), labels=active_module_ids ) + scale_y_discrete( name=&quot;Time Step&quot;, limits=seq(0, 30, 5) ) + # Background tile color geom_tile( color=&quot;white&quot;, size=0.2, width=1, height=1, alpha=0.75 ) + # Highlight actively running functions geom_tile( data=filter(active_data, is_running==TRUE | triggered==TRUE), color=&quot;black&quot;, size=0.8, width=1, height=1 ) + # Environment delimiters geom_hline( yintercept=filter(active_data, cpu_step==0)$time_step - 0.5, size=1.25, color=&quot;black&quot; ) + # Draw points on triggered modules geom_point( data=filter(active_data, triggered==TRUE), shape=8, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + geom_point( data=filter(active_data, is_cur_responding_function==TRUE), shape=21, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + theme( legend.position = &quot;top&quot;, legend.text = element_text(size=9), legend.title=element_text(size=8), axis.text.y = element_text(size=8), axis.title.y = element_text(size=8), axis.text.x = element_text(size=8), axis.title.x = element_text(size=8), plot.title = element_text(hjust = 0.5) ) + coord_flip() + ggsave(out_name, height=2.25, width=4) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? 7.7.3 Environmental signal tag-match score over time Again, we’ll omit unexecuted functions. out_name &lt;- paste0(working_directory, &quot;imgs/case-study-trace-id-&quot;, trace_id, &quot;-similarity-score.pdf&quot;, sep=&quot;&quot;) ggplot(active_data, aes(x=mod_id_x_pos, y=time_step, fill=similarity_score)) + scale_fill_viridis( option=&quot;plasma&quot;, name=&quot;Score: &quot; ) + scale_x_discrete( name=&quot;Function ID&quot;, limits=seq(0, length(active_module_ids)-1, 1), labels=active_module_ids ) + scale_y_discrete( name=&quot;Time Step&quot;, limits=seq(0, 30, 10) ) + # Background geom_tile( color=&quot;white&quot;, size=0.2, width=1, height=1 ) + # Module is-running highlights geom_tile( data=filter(active_data, is_running==TRUE | triggered==TRUE), color=&quot;black&quot;, width=1, height=1, size=0.8 ) + # Environment delimiters geom_hline( yintercept=filter(active_data, cpu_step==0)$time_step-0.5, size=1 ) + # Draw points on triggered modules geom_point( data=filter(active_data, triggered==TRUE), shape=8, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + geom_point( data=filter(active_data, is_cur_responding_function==TRUE), shape=21, colour=&quot;black&quot;, fill=&quot;white&quot;, stroke=0.5, size=1.5, position=position_nudge(x = 0, y = 0.01) ) + theme( legend.position = &quot;top&quot;, legend.text = element_text(size=8), axis.text.y = element_text(size=8), axis.text.x = element_text(size=8) ) + guides(fill = guide_colourbar(barwidth = 10, barheight = 0.5)) + ggtitle(&quot;Function Match Scores&quot;) + ggsave(out_name, height=3, width=4) ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? ## Warning: Continuous limits supplied to discrete scale. ## Did you mean `limits = factor(...)` or `scale_*_continuous()`? 7.7.4 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) ## Warning in read.table(file = file, header = header, sep = sep, quote = quote, : ## incomplete final line found by readTableHeader on &#39;experiments/2020-11-25-rep- ## sig/analysis/data/igraphs/reg_graph_id-20203_nodes.csv&#39; graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=40, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["contextual-signal-problem-analysis.html", "Chapter 8 Contextual-signal problem analysis 8.1 Overview 8.2 Analysis Dependencies 8.3 Setup 8.4 Problem-solving success 8.5 How many generations elapse before solutions evolve? 8.6 Evolved strategies 8.7 Visualizing an evolved gene regulatory network", " Chapter 8 Contextual-signal problem analysis Here, we give an overview of the contextual-signal diagnostic problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 8.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 # Settings for statistical analyses. alpha &lt;- 0.05 # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-27-context-sig/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis In the contextual-signal problem, programs must respond appropriately to a sequence of two input signals where the first, ‘’contextual’‘, signal dictates how a program should respond to each possible second,’‘response’’, signal. In this work, there are a total of four possible input signals and four possible output responses. Programs output these responses by executing one of four response instructions. The dataframe below gives the correct output for each combination of input signals. testcases &lt;- read.csv(paste0(working_directory, &quot;../hpcc/examples_S4.csv&quot;)) print(testcases) ## input output type ## 1 OP:S0;OP:S0 0 S0;S0 ## 2 OP:S0;OP:S1 1 S0;S1 ## 3 OP:S0;OP:S2 2 S0;S2 ## 4 OP:S0;OP:S3 3 S0;S3 ## 5 OP:S1;OP:S0 1 S1;S0 ## 6 OP:S1;OP:S1 2 S1;S1 ## 7 OP:S1;OP:S2 3 S1;S2 ## 8 OP:S1;OP:S3 0 S1;S3 ## 9 OP:S2;OP:S0 2 S2;S0 ## 10 OP:S2;OP:S1 3 S2;S1 ## 11 OP:S2;OP:S2 0 S2;S2 ## 12 OP:S2;OP:S3 1 S2;S3 ## 13 OP:S3;OP:S0 3 S3;S0 ## 14 OP:S3;OP:S1 0 S3;S1 ## 15 OP:S3;OP:S2 1 S3;S2 ## 16 OP:S3;OP:S3 2 S3;S3 8.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) library(reshape2) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 8.3 Setup Load data, initial data cleanup, configure some global settings. ####### Load max fit program data ####### data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). data$matchbin_thresh &lt;- factor( data$matchbin_thresh, levels=c(0, 25, 50, 75) ) data$TAG_LEN &lt;- factor( data$TAG_LEN, levels=c(32, 64, 128, 256) ) data$task &lt;- factor( data$task, levels=c(&quot;S2&quot;, &quot;S3&quot;, &quot;S4&quot;) ) # Filter down to only data we use in paper. data &lt;- filter(data, task==&quot;S4&quot;) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Given knockout info, what strategy does a program use? get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). data$strategy &lt;- mapply( get_strategy, data$relies_on_regulation, data$relies_on_global_memory ) data$strategy &lt;- factor( data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(data, solution==&quot;1&quot;) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;), na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$task &lt;- factor( inst_exec_data$task, levels=c(&quot;S2&quot;, &quot;S3&quot;, &quot;S4&quot;) ) ####### Load network data ####### reg_network_data &lt;- read.csv(paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;), na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% data$SEED) get_task &lt;- function(seed) { return(filter(data, SEED==seed)$task) } reg_network_data$task &lt;- mapply( get_task, reg_network_data$run_id ) reg_network_data$task &lt;- factor(reg_network_data$task) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 8.4 Problem-solving success The number of successful replicates by condition: # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot(filter(sol_data, task==&quot;S4&quot;), aes(x=condition, fill=condition)) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates&quot;) + theme(legend.position = &quot;none&quot;) + ggsave( paste0(working_directory, &quot;imgs/context-signal-solution-counts.pdf&quot;), width=4, height=4 ) Test for significance using Fisher’s exact test. # Extract successes/fails for each condition. reg_disabled_success_cnt &lt;- nrow(filter(sol_data, task==&quot;S4&quot; &amp; solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) reg_disabled_fail_cnt &lt;- replicates - reg_disabled_success_cnt reg_enabled_success_cnt &lt;- nrow(filter(sol_data, task==&quot;S4&quot; &amp; solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) reg_enabled_fail_cnt &lt;- replicates - reg_enabled_success_cnt # Regulation-disabled vs regulation-enabled perf_table &lt;- matrix( c( reg_enabled_success_cnt, reg_disabled_success_cnt, reg_enabled_fail_cnt, reg_disabled_fail_cnt ), nrow=2 ) rownames(perf_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(perf_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(perf_table) ## success fail ## reg-enabled 200 0 ## reg-disabled 173 27 print(fisher.test(perf_table)) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: perf_table ## p-value = 5.818e-09 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 7.714282 Inf ## sample estimates: ## odds ratio ## Inf 8.5 How many generations elapse before solutions evolve? ggplot( data = filter(sol_data, task==&quot;S4&quot;), aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position=position_nudge(x = .2, y = 0), alpha=.8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous(name=&quot;Generation first solution evolved&quot;) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;imgs/context-signal-solve-time-cloud.png&quot;), width=4, height=4 ) Test for statistical difference between conditions using a Wilcoxon rank sum test. print(wilcox.test(formula=update~condition, data=filter(sol_data, task==&quot;S4&quot;), exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 28950, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 557.9999 764.0000 ## sample estimates: ## difference in location ## 657 8.6 Evolved strategies 8.6.1 What mechanisms do programs rely on to adjust responses to signals over time? We used indpendent knockouts of tag-based genetic regulation and global memory buffer access to investigate the mechanisms underpinning successful programs. ggplot( filter(sol_data, task==&quot;S4&quot;), mapping=aes(x=condition, fill=strategy) ) + geom_bar( position=&quot;fill&quot;, stat=&quot;count&quot; ) + geom_text( stat=&#39;count&#39;, mapping=aes(label=..count..), position=position_fill(vjust=0.05) ) + ylab(&quot;% of Solutions&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ), labels=c( &quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot; ) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme(legend.position = &quot;bottom&quot;) 8.6.2 Gene regulatory networks Looking only at successful programs that rely on regulation. At a glance, what do gene regulatory networks look like? First, the total edges found in networks: relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg &amp; task==&quot;S4&quot;), aes(x=task, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Task&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/contextual-signal-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Process/cleanup the network data melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg ), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot(filter(melted_network_data, task==&quot;S4&quot;), aes(x=reg_edge_type, y=reg_edges_cnt, color=reg_edge_type)) + geom_boxplot() + geom_jitter(alpha=0.2) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_x_discrete( name=&quot;Edge type&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;none&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/context-signal-regulation-edge-types.png&quot;), width=4, height=3 ) Test for a statistical difference between edge types using a wilcoxon rank sum test: print( paste0( &quot;Median # repressed edges: &quot;, median(filter(melted_network_data, task==&quot;S4&quot; &amp; reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # repressed edges: 62&quot; print( paste0( &quot;Median # promoting edges: &quot;, median(filter(melted_network_data, task==&quot;S4&quot; &amp; reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # promoting edges: 73&quot; print(wilcox.test(formula=reg_edges_cnt ~ reg_edge_type, data=filter(melted_network_data, task==&quot;S4&quot;), exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 15690, p-value = 0.0001927 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -13.000026 -4.000018 ## sample estimates: ## difference in location ## -8.000026 8.6.3 Program instruction execution traces 8.6.3.1 Execution time How many time steps do evolved programs use to solve the contextual-signal task? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED &amp; task==&quot;S4&quot;) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme( legend.position=&quot;none&quot; ) Test for significant difference between conditions using Wilcoxon rank sum test: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 30794, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 634.0001 810.0000 ## sample estimates: ## difference in location ## 722.8488 8.6.3.2 What types of instructions to successful programs execute? Here, we look at the distribution of instruction types executed by successful programs. We’re primarily interested in the proportion of control flow instructions, so let’s look at that first. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Test for significant difference between conditions using a Wilcoxon rank sum test: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 30479, p-value &lt; 2.2e-16 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.04280319 0.05431491 ## sample estimates: ## difference in location ## 0.04838185 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition:&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled&quot;, &quot;Regulation-enabled&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + coord_flip() + theme(legend.position=&quot;bottom&quot;) 8.7 Visualizing an evolved gene regulatory network Let’s take a closer look at a successful gene regulatory network. trace_id &lt;- 23997 Specifically, we’ll be looking at the solution evolved in run id 2.3997^{4} (arbitrarily selected). 8.7.1 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=10, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["boolean-calculator-problem-prefix-notation.html", "Chapter 9 Boolean calculator problem (prefix notation) 9.1 Overview 9.2 Analysis Dependencies 9.3 Setup 9.4 Problem-solving success 9.5 How many generations elapse before solutions evolve? 9.6 Evolved strategies 9.7 Visualizaing an evolved regulatory network", " Chapter 9 Boolean calculator problem (prefix notation) Here, we give an overview of the boolean logic calculator problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 9.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 # Settings for statistical analyses. alpha &lt;- 0.05 # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-28-bool-calc-prefix/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis The Boolean logic calculator problem requires programs to implement a calculator capable of performing each of the following 10 bitwise logic operations: ECHO, NOT, NAND, AND, OR-NOT, OR, AND-NOT, NOR, XOR, and EQUALS. In this problem, there are 11 distinct types of input signals: one for each of the 10 possible operators and one for numeric inputs. Each distinct signal type is associated with a unique tag and is meant to represent different types of buttons that could be pressed on a physical calculator. Programs receive a sequence of input signals in prefix notation, receiving an operator signal followed by the appropriate number of numeric input signals (that each contain an operand to use in the computation). After receiving the requisite input signals, programs must output the correct result of the requested computation. 9.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) library(reshape2) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 9.3 Setup Load data, initial data cleanup, configure some global settings. data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). data$matchbin_thresh &lt;- factor( data$matchbin_thresh, levels=c(0, 25, 50, 75) ) data$TAG_LEN &lt;- factor( data$TAG_LEN, levels=c(32, 64, 128, 256) ) data$notation &lt;- factor( data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Given knockout info, what strategy does a program use? get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). data$strategy &lt;- mapply( get_strategy, data$relies_on_regulation, data$relies_on_global_memory ) data$strategy &lt;- factor( data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(data, solution==&quot;1&quot;) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;), na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$notation &lt;- factor( inst_exec_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### Load network data ####### reg_network_data &lt;- read.csv(paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;), na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% data$SEED) get_notation &lt;- function(seed) { return(filter(data, SEED==seed)$notation) } reg_network_data$notation &lt;- mapply( get_notation, reg_network_data$run_id ) reg_network_data$notation &lt;- factor( reg_network_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 9.4 Problem-solving success The number of successful replicates by condition: # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot(sol_data, aes(x=condition, fill=condition)) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates&quot;) + ylim(0, 200) + theme(legend.position = &quot;none&quot;) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-solution-counts.pdf&quot;), width=4, height=4 ) Test for significance using Fisher’s exact test. # Extract successes/fails for each condition. reg_disabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) reg_disabled_fail_cnt &lt;- replicates - reg_disabled_success_cnt reg_enabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) reg_enabled_fail_cnt &lt;- replicates - reg_enabled_success_cnt # Regulation-disabled vs regulation-enabled perf_table &lt;- matrix( c( reg_enabled_success_cnt, reg_disabled_success_cnt, reg_enabled_fail_cnt, reg_disabled_fail_cnt ), nrow=2 ) rownames(perf_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(perf_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(perf_table) ## success fail ## reg-enabled 66 134 ## reg-disabled 30 170 print(fisher.test(perf_table)) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: perf_table ## p-value = 3.585e-05 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 1.673731 4.711896 ## sample estimates: ## odds ratio ## 2.783852 9.5 How many generations elapse before solutions evolve? ggplot( data = sol_data, aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position=position_nudge(x = .2, y = 0), alpha=.8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous(name=&quot;Generation first solution evolved&quot;) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-solve-time-cloud.png&quot;), width=4, height=4 ) Test for statistical difference between conditions using a Wilcoxon rank sum test. print(wilcox.test(formula=update~condition, data=sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 1249, p-value = 0.04102 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 45.00003 2448.99997 ## sample estimates: ## difference in location ## 1291.265 9.6 Evolved strategies 9.6.1 What mechanisms do programs rely on to adjust responses to signals over time? We used indpendent knockouts of tag-based genetic regulation and global memory buffer access to investigate the mechanisms underpinning successful programs. ggplot( sol_data, mapping=aes(x=condition, fill=strategy) ) + geom_bar( position=&quot;fill&quot;, stat=&quot;count&quot; ) + geom_text( stat=&#39;count&#39;, mapping=aes(label=..count..), position=position_fill(vjust=0.05) ) + ylab(&quot;% of Solutions&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ), labels=c( &quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot; ) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme(legend.position = &quot;bottom&quot;) 9.6.2 Gene regulatory networks Looking only at successful programs that rely on regulation. At a glance, what do gene regulatory networks look like? First, the total edges found in networks: relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg), aes(x=notation, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Notation&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Process/cleanup the network data melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg ), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot( melted_network_data, aes(x=reg_edge_type, y=reg_edges_cnt, color=reg_edge_type) ) + geom_boxplot() + geom_jitter(alpha=0.2) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_x_discrete( name=&quot;Edge type&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;none&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-prefix-regulation-edge-types.png&quot;), width=4, height=3 ) Test for a statistical difference between edge types using a wilcoxon rank sum test: print( paste0( &quot;Median # repressed edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # repressed edges: 34&quot; print( paste0( &quot;Median # promoting edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # promoting edges: 36&quot; print(wilcox.test(formula=reg_edges_cnt ~ reg_edge_type, data=melted_network_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 1961.5, p-value = 0.3254 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -8.999963 2.999998 ## sample estimates: ## difference in location ## -2.999964 9.6.3 Program instruction execution traces 9.6.3.1 Execution time How many time steps do successful programs take to solve the boolean calculator problem? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme( legend.position=&quot;none&quot; ) Test for significant difference between conditions using Wilcoxon rank sum test: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 1374, p-value = 0.002434 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 240 986 ## sample estimates: ## difference in location ## 587.0774 9.6.3.2 What types of instructions to successful programs execute? Here, we look at the distribution of instruction types executed by successful programs. We’re primarily interested in the proportion of control flow instructions, so let’s look at that first. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Test for significant difference between conditions using a Wilcoxon rank sum test: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 1541.5, p-value = 1.328e-05 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## 0.01486019 0.03910795 ## sample estimates: ## difference in location ## 0.02639857 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition:&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled&quot;, &quot;Regulation-enabled&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + coord_flip() + theme(legend.position=&quot;bottom&quot;) 9.7 Visualizaing an evolved regulatory network Let’s take a closer look at a successful gene regulatory network. trace_id &lt;- 24386 Specifically, we’ll be looking at the solution evolved in run id 2.4386^{4} (arbitrarily selected). 9.7.1 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=10, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["boolean-calculator-problem-postfix-notation.html", "Chapter 10 Boolean calculator problem (postfix notation) 10.1 Overview 10.2 Analysis Dependencies 10.3 Setup 10.4 Problem-solving success 10.5 How many generations elapse before solutions evolve? 10.6 Evolved strategies 10.7 Visualizaing an evolved regulatory network", " Chapter 10 Boolean calculator problem (postfix notation) Here, we give an overview of the boolean logic calculator problem, and we provide our data analyses for related experiments. All of our source code for statistical analyses and data visualizations is embedded in this document. The raw data can be found on the OSF project associated with this work (link coming). Please file an issue or make a pull request on github to report any mistakes, ask questions, request more explanation, et cetera. 10.1 Overview # Experimental parameters referenced in-text all in one convenient place. time_steps &lt;- 128 replicates &lt;- 200 population_size &lt;- 1000 generations &lt;- 10000 # Settings for statistical analyses. alpha &lt;- 0.05 # Relative location of data. working_directory &lt;- &quot;experiments/2020-11-28-bool-calc-postfix/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis We use a modified version of the Boolean logic calculator problem to further investigate the potential for our implementation of tag-based regulation to impede adaptive evolution. Our previous experiments with the Boolean logic calculator problem provided inputs in prefix notation: the operator (e.g., AND, OR, XOR, etc.) is specified first, followed by the requisite number of numeric operands. As such, the final input signal does not differentiate which type of computation a program is expected to perform (e.g., AND, OR, XOR, etc.). This requires programs to adjust their response to the final input signal based on the context provided by the previous two signals, thereby increasing the value of regulation. We explore whether the calculator problem’s context-dependence is driving the benefit of tag-based regulation that we identified in previous experiments. We can reduce context-dependence of the calculator problem by presenting input sequences in postfix notation. In postfix notation, programs receive the requisite numeric operand inputs first and the operator input last. As such, the final signal in an input sequence will always differentiate which bitwise operation should be performed. Successful programs must store the numeric inputs embedded in operand signals, and then, as in the changing-signal problem, a distinct signal will differentiate which of the response types a program should execute. 10.2 Analysis Dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(viridis) library(reshape2) library(igraph) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.2 ## year 2020 ## month 06 ## day 22 ## svn rev 78730 ## language R ## version.string R version 4.0.2 (2020-06-22) ## nickname Taking Off Again 10.3 Setup Load data, initial data cleanup, configure some global settings. data_loc &lt;- paste0(working_directory, &quot;data/max_fit_orgs.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) # Specify factors (not all of these matter for this set of runs). data$matchbin_thresh &lt;- factor( data$matchbin_thresh, levels=c(0, 25, 50, 75) ) data$TAG_LEN &lt;- factor( data$TAG_LEN, levels=c(32, 64, 128, 256) ) data$notation &lt;- factor( data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) # Define function to summarize regulation/memory configurations. get_con &lt;- function(reg, mem) { if (reg == &quot;0&quot; &amp;&amp; mem == &quot;0&quot;) { return(&quot;none&quot;) } else if (reg == &quot;0&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;memory&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;0&quot;) { return(&quot;regulation&quot;) } else if (reg==&quot;1&quot; &amp;&amp; mem==&quot;1&quot;) { return(&quot;both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental condition for each datum. data$condition &lt;- mapply( get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY ) data$condition &lt;- factor( data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) # Given knockout info, what strategy does a program use? get_strategy &lt;- function(use_reg, use_mem) { if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use neither&quot;) } else if (use_reg==&quot;0&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use memory&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;0&quot;) { return(&quot;use regulation&quot;) } else if (use_reg==&quot;1&quot; &amp;&amp; use_mem==&quot;1&quot;) { return(&quot;use both&quot;) } else { return(&quot;UNKNOWN&quot;) } } # Specify experimental conditions (to make labeling easier). data$strategy &lt;- mapply( get_strategy, data$relies_on_regulation, data$relies_on_global_memory ) data$strategy &lt;- factor( data$strategy, levels=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ) ) # Filter data to include only replicates labeled as solutions sol_data &lt;- filter(data, solution==&quot;1&quot;) ####### Load instruction execution data ####### inst_exec_data &lt;- read.csv(paste0(working_directory, &quot;data/exec_trace_summary.csv&quot;), na.strings=&quot;NA&quot;) inst_exec_data$condition &lt;- mapply( get_con, inst_exec_data$USE_FUNC_REGULATION, inst_exec_data$USE_GLOBAL_MEMORY ) inst_exec_data$condition &lt;- factor( inst_exec_data$condition, levels=c(&quot;regulation&quot;, &quot;memory&quot;, &quot;none&quot;, &quot;both&quot;) ) inst_exec_data$notation &lt;- factor( inst_exec_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### Load network data ####### reg_network_data &lt;- read.csv(paste0(working_directory, &quot;data/reg_graphs_summary.csv&quot;), na.strings=&quot;NA&quot;) reg_network_data &lt;- filter(reg_network_data, run_id %in% data$SEED) get_notation &lt;- function(seed) { return(filter(data, SEED==seed)$notation) } reg_network_data$notation &lt;- mapply( get_notation, reg_network_data$run_id ) reg_network_data$notation &lt;- factor( reg_network_data$notation, levels=c(&quot;prefix&quot;, &quot;postfix&quot;) ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 10.4 Problem-solving success The number of successful replicates by condition: # Graph the number of solutions evolved in each condition, faceted by environmental complexity ggplot(sol_data, aes(x=condition, fill=condition)) + geom_bar() + geom_text( stat=&quot;count&quot;, mapping=aes(label=..count..), position=position_dodge(0.9), vjust=0 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;,&quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;# successful replciates&quot;) + ylim(0, 200) + theme(legend.position = &quot;none&quot;) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-solution-counts.pdf&quot;), width=4, height=4 ) Test for significance using Fisher’s exact test. # Extract successes/fails for each condition. reg_disabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;memory&quot;)) reg_disabled_fail_cnt &lt;- replicates - reg_disabled_success_cnt reg_enabled_success_cnt &lt;- nrow(filter(sol_data, solution==&quot;1&quot; &amp; condition==&quot;both&quot;)) reg_enabled_fail_cnt &lt;- replicates - reg_enabled_success_cnt # Regulation-disabled vs regulation-enabled perf_table &lt;- matrix( c( reg_enabled_success_cnt, reg_disabled_success_cnt, reg_enabled_fail_cnt, reg_disabled_fail_cnt ), nrow=2 ) rownames(perf_table) &lt;- c(&quot;reg-enabled&quot;, &quot;reg-disabled&quot;) colnames(perf_table) &lt;- c(&quot;success&quot;, &quot;fail&quot;) print(perf_table) ## success fail ## reg-enabled 120 80 ## reg-disabled 151 49 print(fisher.test(perf_table)) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: perf_table ## p-value = 0.001286 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.3093253 0.7635173 ## sample estimates: ## odds ratio ## 0.4876392 10.5 How many generations elapse before solutions evolve? ggplot( data = sol_data, aes(x=condition, y=update, fill=condition) ) + geom_flat_violin( position=position_nudge(x = .2, y = 0), alpha=.8 ) + geom_point( aes(y=update, color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + scale_y_continuous(name=&quot;Generation first solution evolved&quot;) + guides(fill = FALSE) + guides(color = FALSE) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-solve-time-cloud.png&quot;), width=4, height=4 ) Test for statistical difference between conditions using a Wilcoxon rank sum test. print(wilcox.test(formula=update~condition, data=sol_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: update by condition ## W = 7175.5, p-value = 0.003285 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -1422 -310 ## sample estimates: ## difference in location ## -872 10.6 Evolved strategies 10.6.1 What mechanisms do programs rely on to adjust responses to signals over time? We used indpendent knockouts of tag-based genetic regulation and global memory buffer access to investigate the mechanisms underpinning successful programs. ggplot( sol_data, mapping=aes(x=condition, fill=strategy) ) + geom_bar( position=&quot;fill&quot;, stat=&quot;count&quot; ) + geom_text( stat=&#39;count&#39;, mapping=aes(label=..count..), position=position_fill(vjust=0.05) ) + ylab(&quot;% of Solutions&quot;) + scale_fill_discrete( name=&quot;Strategy:&quot;, breaks=c( &quot;use regulation&quot;, &quot;use memory&quot;, &quot;use neither&quot;, &quot;use both&quot; ), labels=c( &quot;Use regulation (only)&quot;, &quot;Use global memory (only)&quot;, &quot;Use neither&quot;, &quot;Use both&quot; ) ) + scale_x_discrete( name=&quot;Condition&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme(legend.position = &quot;bottom&quot;) 10.6.2 Gene regulatory networks Looking only at successful programs that rely on regulation. At a glance, what do gene regulatory networks look like? First, the total edges found in networks: relies_on_reg &lt;- filter( sol_data, relies_on_regulation==&quot;1&quot; )$SEED ggplot( filter(reg_network_data, run_id %in% relies_on_reg), aes(x=notation, y=edge_cnt) ) + geom_boxplot() + geom_jitter(alpha=0.1) + xlab(&quot;Notation&quot;) + ylab(&quot;# Edges&quot;) + theme( legend.position=&quot;bottom&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-regulation-edges.png&quot;), width=4, height=3 ) Next, let’s look at edges by type. # Process/cleanup the network data melted_network_data &lt;- melt( filter(reg_network_data, run_id %in% relies_on_reg ), variable.name = &quot;reg_edge_type&quot;, value.name = &quot;reg_edges_cnt&quot;, measure.vars=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;) ) ggplot( melted_network_data, aes(x=reg_edge_type, y=reg_edges_cnt, color=reg_edge_type) ) + geom_boxplot() + geom_jitter(alpha=0.2) + xlab(&quot;Environmental Complexity&quot;) + ylab(&quot;# Edges&quot;) + scale_x_discrete( name=&quot;Edge type&quot;, limits=c(&quot;repressed_edges_cnt&quot;, &quot;promoted_edges_cnt&quot;), labels=c(&quot;Repressing edges&quot;, &quot;Promoting edges&quot;) ) + theme( legend.position=&quot;none&quot;, legend.text=element_text(size=9), legend.title=element_text(size=10), axis.title.x=element_text(size=12) ) + ggsave( paste0(working_directory, &quot;imgs/boolean-calc-postfix-regulation-edge-types.png&quot;), width=4, height=3 ) Test for a statistical difference between edge types using a wilcoxon rank sum test: print( paste0( &quot;Median # repressed edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;repressed_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # repressed edges: 41&quot; print( paste0( &quot;Median # promoting edges: &quot;, median(filter(melted_network_data, reg_edge_type==&quot;promoted_edges_cnt&quot;)$reg_edges_cnt) ) ) ## [1] &quot;Median # promoting edges: 43&quot; print(wilcox.test(formula=reg_edges_cnt ~ reg_edge_type, data=melted_network_data, exact=FALSE, conf.int=TRUE)) ## ## Wilcoxon rank sum test with continuity correction ## ## data: reg_edges_cnt by reg_edge_type ## W = 4411, p-value = 0.4535 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -7.999975 3.000061 ## sample estimates: ## difference in location ## -1.999985 10.6.3 Program instruction execution traces 10.6.3.1 Execution time How many time steps do successful programs take to solve the boolean calculator problem? # only want solutions solutions_inst_exec_data &lt;- filter(inst_exec_data, SEED %in% sol_data$SEED) ggplot( solutions_inst_exec_data, aes(x=condition, y=total_execution_time, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + theme( legend.position=&quot;none&quot; ) Test for significant difference between conditions using Wilcoxon rank sum test: print( wilcox.test( formula=total_execution_time~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: total_execution_time by condition ## W = 9737, p-value = 0.2912 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -78.00002 274.00000 ## sample estimates: ## difference in location ## 96.00004 10.6.3.2 What types of instructions to successful programs execute? Here, we look at the distribution of instruction types executed by successful programs. We’re primarily interested in the proportion of control flow instructions, so let’s look at that first. ggplot( solutions_inst_exec_data, aes(x=condition, y=control_flow_inst_prop, color=condition) ) + geom_boxplot() + geom_jitter(alpha=0.2) + scale_x_discrete( breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-\\ndisabled&quot;, &quot;Regulation-\\nenabled&quot;) ) + ylab(&quot;Proportion of executed flow control instructions&quot;) + theme( legend.position=&quot;bottom&quot;, axis.title.x=element_blank() ) Test for significant difference between conditions using a Wilcoxon rank sum test: print( wilcox.test( formula=control_flow_inst_prop~condition, data=filter(solutions_inst_exec_data), exact=FALSE, conf.int=TRUE) ) ## ## Wilcoxon rank sum test with continuity correction ## ## data: control_flow_inst_prop by condition ## W = 8043, p-value = 0.1127 ## alternative hypothesis: true location shift is not equal to 0 ## 95 percent confidence interval: ## -0.011679066 0.001195076 ## sample estimates: ## difference in location ## -0.00543344 In case you’re curious, here’s all categories of instructions: melted &lt;- melt( solutions_inst_exec_data, variable.name = &quot;inst_type&quot;, value.name = &quot;inst_type_prop&quot;, measure.vars=c( &quot;math_inst_prop&quot;, &quot;module_inst_prop&quot;, &quot;memory_inst_prop&quot;, &quot;regulation_inst_prop&quot;, &quot;control_flow_inst_prop&quot;, &quot;thread_inst_prop&quot;, &quot;task_inst_prop&quot;, &quot;nop_inst_prop&quot; ) ) ggplot( melted, aes(x=inst_type, y=inst_type_prop, color=condition) ) + geom_boxplot() + scale_color_discrete( name=&quot;Condition:&quot;, breaks=c(&quot;memory&quot;, &quot;both&quot;), labels=c(&quot;Regulation-disabled&quot;, &quot;Regulation-enabled&quot;) ) + xlab(&quot;Instruction type&quot;) + ylab(&quot;Proportion of instructions in execution trace&quot;) + coord_flip() + theme(legend.position=&quot;bottom&quot;) 10.7 Visualizaing an evolved regulatory network Let’s take a closer look at a successful gene regulatory network. trace_id &lt;- 25392 Specifically, we’ll be looking at the solution evolved in run id 2.5392^{4} (arbitrarily selected). 10.7.1 Evolved regulatory network We use the igraph package to draw this program’s gene regulatory network. # Networks! graph_nodes_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_nodes.csv&quot;) graph_edges_loc &lt;- paste0(working_directory, &quot;data/igraphs/reg_graph_id-&quot;, trace_id, &quot;_edges.csv&quot;) graph_nodes_data &lt;- read.csv(graph_nodes_loc, na.strings=&quot;NONE&quot;) graph_edges_data &lt;- read.csv(graph_edges_loc, na.strings=&quot;NONE&quot;) network &lt;- graph_from_data_frame( d=graph_edges_data, vertices=graph_nodes_data, directed=TRUE ) # Setup edge styling E(network)$color[E(network)$type == &quot;promote&quot;] &lt;- &quot;#FCE640&quot; E(network)$lty[E(network)$type == &quot;promote&quot;] &lt;- 1 E(network)$color[E(network)$type == &quot;repress&quot;] &lt;- &quot;#441152&quot; E(network)$lty[E(network)$type == &quot;repress&quot;] &lt;- 1 network_out_name &lt;- paste0(working_directory, &quot;imgs/case-study-id-&quot;, trace_id, &quot;-network.svg&quot;) draw_network &lt;- function(net, write_out, out_name) { if (write_out) { svg(out_name, width=4,height=1.5) # bottom, left, top, right par(mar=c(0.2,0,1,0.5)) } plot( net, edge.arrow.size=0.4, edge.arrow.width=0.75, edge.width=2, vertex.size=10, vertex.label.cex=0.65, curved=TRUE, vertex.color=&quot;grey99&quot;, vertex.label.color=&quot;black&quot;, vertex.label.family=&quot;sans&quot;, layout=layout.circle(net) ) legend( x = &quot;bottomleft&quot;, ## position, also takes x,y coordinates legend = c(&quot;Promoted&quot;, &quot;Repressed&quot;), pch = 19, ## legend symbols see ?points col = c(&quot;#FCE640&quot;, &quot;#441152&quot;), bty = &quot;n&quot;, border=&quot;black&quot;, xpd=TRUE, title = &quot;Edges&quot; ) if (write_out) { dev.flush() dev.off() } } draw_network(network, TRUE, network_out_name) ## png ## 2 draw_network(network, FALSE, &quot;&quot;) "],["references.html", "References", " References Csardi, Gabor, and Tamas Nepusz. 2006. “The Igraph Software Package for Complex Network Research.” InterJournal Complex Systems: 1695. https://igraph.org. file., See AUTHORS. 2020. Igraph: Network Analysis and Visualization. https://igraph.org. Garnier, Simon. 2018a. Viridis: Default Color Maps from Matplotlib. https://github.com/sjmgarnier/viridis. ———. 2018b. ViridisLite: Default Color Maps from Matplotlib (Lite Version). https://github.com/sjmgarnier/viridisLite. Henry, Lionel, and Hadley Wickham. 2020. Purrr: Functional Programming Tools. https://CRAN.R-project.org/package=purrr. Lalejini, Alexander M, Matthew A Moreno, and Charles Ofria. 2020. “Tag-Based Genetic Regulation for Genetic Programming.” OSF. https://doi.org/10.17605/OSF.IO/928FX. Lalejini, Alexander, and Charles Ofria. 2018. “Evolving Event-Driven Programs with SignalGP.” In Proceedings of the Genetic and Evolutionary Computation Conference on - GECCO ’18, 1135–42. Kyoto, Japan: ACM Press. https://doi.org/10.1145/3205455.3205523. Lalejini, Alexander, Michael J. Wiser, and Charles Ofria. 2017. “Gene Duplications Drive the Evolution of Complex Traits and Regulation.” In Proceedings of the 14th European Conference on Artificial Life ECAL 2017, 257–64. Lyon, France: MIT Press. https://doi.org/10.7551/ecal_a_045. Müller, Kirill, and Hadley Wickham. 2020. Tibble: Simple Data Frames. https://CRAN.R-project.org/package=tibble. Neuwirth, Erich. 2014. RColorBrewer: ColorBrewer Palettes. https://CRAN.R-project.org/package=RColorBrewer. R Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Spector, Lee, Brian Martin, Kyle Harrington, and Thomas Helmuth. 2011. “Tag-Based Modules in Genetic Programming.” In Proceedings of the 13th Annual Conference on Genetic and Evolutionary Computation - GECCO ’11, 1419. Dublin, Ireland: ACM Press. https://doi.org/10.1145/2001576.2001767. Wickham, Hadley. 2007. “Reshaping Data with the reshape Package.” Journal of Statistical Software 21 (12): 1–20. http://www.jstatsoft.org/v21/i12/. ———. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org. ———. 2019a. Stringr: Simple, Consistent Wrappers for Common String Operations. https://CRAN.R-project.org/package=stringr. ———. 2019b. Tidyverse: Easily Install and Load the Tidyverse. https://CRAN.R-project.org/package=tidyverse. ———. 2020a. Forcats: Tools for Working with Categorical Variables (Factors). https://CRAN.R-project.org/package=forcats. ———. 2020b. Reshape2: Flexibly Reshape Data: A Reboot of the Reshape Package. https://github.com/hadley/reshape. ———. 2020c. Tidyr: Tidy Messy Data. https://CRAN.R-project.org/package=tidyr. Wickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain François, Garrett Grolemund, et al. 2019. “Welcome to the tidyverse.” Journal of Open Source Software 4 (43): 1686. https://doi.org/10.21105/joss.01686. Wickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey Dunnington. 2020. Ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics. https://CRAN.R-project.org/package=ggplot2. Wickham, Hadley, Romain François, Lionel Henry, and Kirill Müller. 2020. Dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr. Wickham, Hadley, and Jim Hester. 2020. Readr: Read Rectangular Text Data. https://CRAN.R-project.org/package=readr. Wilke, Claus O. 2020. Cowplot: Streamlined Plot Theme and Plot Annotations for Ggplot2. https://wilkelab.org/cowplot/. Xie, Yihui. 2016. Bookdown: Authoring Books and Technical Documents with R Markdown. Boca Raton, Florida: Chapman; Hall/CRC. https://github.com/rstudio/bookdown. ———. 2020. Bookdown: Authoring Books and Technical Documents with R Markdown. https://github.com/rstudio/bookdown. "]]
